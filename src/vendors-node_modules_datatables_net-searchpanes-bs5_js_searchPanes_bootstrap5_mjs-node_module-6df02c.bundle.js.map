{"version":3,"file":"./src/vendors-node_modules_datatables_net-searchpanes-bs5_js_searchPanes_bootstrap5_mjs-node_module-6df02c.bundle.js","mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;;AAEuB;AACoB;AACU;;AAErD,0CAAQ,OAAO,6EAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,0CAAQ,OAAO,8EAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA,YAAY,oFAAmC;AAC/C;AACA;AACA;AACA,CAAC;;;AAGD,iEAAe,0DAAS,EAAC;;;;;;;;;;;;;;;;;AClCzB;AACA;AACA;;AAEuB;AACgB;;AAEvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,oCAAoC;AACpC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA,0GAA0G;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,oDAAoD,8BAA8B;AAClF,8DAA8D,8BAA8B;AAC5F;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gBAAgB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,8BAA8B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gBAAgB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,sBAAsB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,gBAAgB;AAC5E;AACA;AACA,mEAAmE,gBAAgB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA,mDAAmD,gCAAgC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mCAAmC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb,yEAAyE,8BAA8B;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,0CAA0C;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA,mFAAmF,qCAAqC;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gBAAgB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,gBAAgB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,gBAAgB,uCAAuC,mBAAmB;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,uBAAuB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2BAA2B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,MAAM;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2CAA2C;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,gBAAgB,+BAA+B;AACvF;AACA,2BAA2B;AAC3B,oFAAoF,gBAAgB;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,gBAAgB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,qCAAqC;AACrC,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2CAA2C;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qJAAqJ;AACrJ;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,SAAS;AAClF;AACA;AACA,mEAAmE,gBAAgB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,4BAA4B;AACxF;AACA;AACA,oFAAoF,gBAAgB;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,0BAA0B;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,gBAAgB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,8BAA8B;AAC9B,8BAA8B;AAC9B,gCAAgC;AAChC;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,2DAA2D;AACjG;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,gBAAgB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gBAAgB;AACrE;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,gBAAgB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,sBAAsB;AACtB;AACA;AACA;AACA,mCAAmC;AACnC,yBAAyB,MAAM;AAC/B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,mBAAmB,gBAAgB,sCAAsC,kBAAkB;AAC3F,kCAAkC;AAClC;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,gBAAgB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,gBAAgB;AAClF;AACA;AACA;AACA;AACA,wCAAwC,qBAAqB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,wBAAwB;AAChF;AACA,wEAAwE,gBAAgB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,gBAAgB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,mBAAmB,uBAAuB,gBAAgB;AACjH;AACA;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,gBAAgB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,sBAAsB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,mBAAmB,gBAAgB,sCAAsC,kBAAkB;AAC3F,kCAAkC;AAClC;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO,EAAE,MAAM;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,MAAM;AACjC,2BAA2B,MAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,mBAAmB,gBAAgB,sCAAsC,kBAAkB;AAC3F,kCAAkC;AAClC;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,wBAAwB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,mBAAmB,uBAAuB,gBAAgB;AACrH;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,gBAAgB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qBAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,wBAAwB;AAChF;AACA,wEAAwE,gBAAgB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,mBAAmB,uBAAuB,gBAAgB;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mBAAmB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,uBAAuB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2BAA2B;AAC/D;AACA;AACA;AACA;AACA,oCAAoC,2BAA2B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,MAAM;AACjC,2BAA2B,MAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,mBAAmB,gBAAgB,sCAAsC,kBAAkB;AAC3F,kCAAkC;AAClC;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,MAAM;AACnC,qCAAqC,OAAO,EAAE,MAAM;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,mBAAmB,uBAAuB,gBAAgB;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,MAAM;AACjC,2BAA2B,MAAM;AACjC;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,gBAAgB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2BAA2B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA,oDAAoD,gBAAgB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,oDAAoD,gBAAgB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,gBAAgB;AAClF;AACA,6DAA6D,gBAAgB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA,oDAAoD,gBAAgB,uCAAuC,mBAAmB;AAC9H;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,iCAAiC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,6BAA6B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,0BAA0B;AAClF;AACA;AACA,oDAAoD,gBAAgB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kDAAkD;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,+BAA+B;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,gDAAgD,gBAAgB;AAChE;AACA;AACA,mEAAmE,gCAAgC;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,mFAAmF,6BAA6B;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,gBAAgB;AAC/E,4CAA4C,oBAAoB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,uDAAuD,+CAA+C,0BAA0B,IAAI;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,gBAAgB;AAC7E;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gBAAgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,kEAAkE,iCAAiC;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,iBAAiB;AACjB;AACA,yBAAyB,MAAM;AAC/B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,mBAAmB,gBAAgB,sCAAsC,kBAAkB;AAC3F,kCAAkC;AAClC;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,wCAAwC;AACxC;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,gBAAgB;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,gBAAgB;AAClF;AACA,6DAA6D,gBAAgB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,iCAAiC;AACjC,kEAAkE,0CAA0C;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gBAAgB,uCAAuC,mBAAmB;AAC5H,0FAA0F,6CAA6C;AACvI;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,mBAAmB;AAC/F;AACA;AACA;AACA;AACA,oDAAoD,gBAAgB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,gBAAgB;AAC5E;AACA;AACA,wDAAwD,gBAAgB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2BAA2B;AAC/D;AACA,sDAAsD,mBAAmB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,gBAAgB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,gBAAgB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,gBAAgB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,mCAAC;AACjB,cAAc,mCAAC;AACf,gBAAgB,mCAAC;AACjB,gBAAgB,mCAAC;AACjB,gBAAgB,mCAAC;AACjB,oBAAoB,gDAAc;AAClC;AACA;AACA;AACA,IAAI,kEAAqB;AACzB;AACA;AACA;AACA,IAAI,oEAAuB;AAC3B;AACA;AACA;AACA,IAAI,iEAAoB;AACxB;AACA;AACA;AACA,IAAI,0EAA6B;AACjC;AACA;AACA;AACA,IAAI,wEAA2B;AAC/B;AACA;AACA;AACA,IAAI,iFAAoC;AACxC;AACA,sBAAsB,6DAA2B;AACjD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,mFAAsC;AAC1C;AACA;AACA,SAAS;AACT;AACA;AACA,IAAI,8EAAiC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,kBAAkB;AAClB;AACA;AACA;AACA,yBAAyB,0CAAQ;AACjC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,gBAAgB,oEAAuB;AACvC,gBAAgB,kEAAqB;AACrC;AACA;AACA;AACA;AACA,kCAAkC;AAClC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,mCAAC;AACL;AACA;AACA;AACA;AACA,YAAY,2EAA8B;AAC1C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI,uEAA0B;AAC9B;AACA;AACA,KAAK;AACL;AACA,QAAQ,mEAAsB;AAC9B,QAAQ,4EAA+B;AACvC;;AAEA,CAAC;;;AAGD,iEAAe,sDAAS,EAAC;;;;;;;;;;;;;;;;;;AC/0GzB;AACA;AACA;;AAEuB;AACoB;AACA;;;;AAI3C,iEAAe,0DAAS,EAAC;;;;;;;;;;;;;;;;;ACVzB;AACA;AACA;;AAEuB;AACgB;;;AAGvC;AACA,6DAAgB;;AAEhB,qEAAwB;;AAExB,kEAAqB;AACrB;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C,qCAAqC,cAAc;AACnD,iCAAiC,cAAc;AAC/C,YAAY;AACZ,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA,GAAG;;AAEH;AACA,gBAAgB,sEAAyB;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iDAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,CAAC,6EAA2C;AAC5C,kCAAkC,gBAAgB;AAClD;AACA,WAAW,mCAAC;AACZ,KAAK;AACL,WAAW,mCAAC;AACZ;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,oBAAoB,mCAAC;AACrB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,eAAe;AAC3B,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA,2BAA2B,oBAAoB;;AAE/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC,mCAAC;AACF;AACA;AACA;;AAEA,CAAC,mCAAC;AACF;;AAEA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA,iBAAiB,mCAAC;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,mCAAC;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,QAAQ,mCAAC;AACT;AACA;;AAEA,uBAAuB,mCAAC;;AAExB;AACA;AACA;AACA;AACA;;AAEA,eAAe,yCAAO;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;;AAEJ;AACA,CAAC,mCAAC;AACF;AACA;AACA,QAAQ,mCAAC;AACT;AACA;;AAEA;AACA;AACA,QAAQ,mCAAC;AACT;AACA;;AAEA;AACA,QAAQ,mCAAC;AACT;AACA;;AAEA,eAAe,yCAAO;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,YAAY,cAAc;AAC1B,YAAY,cAAc;AAC1B,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,CAAC,mCAAC;AACF;;AAEA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,iBAAiB;AAC5C,8BAA8B,iBAAiB;AAC/C,4BAA4B,iBAAiB;;AAE7C;AACA,aAAa,mCAAC;AACd;AACA,KAAK,6DAA6D;AAClE;AACA;AACA;;AAEA;AACA,CAAC,wCAAM;AACP,OAAO,mCAAC;;AAER,gBAAgB,mCAAC;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA,eAAe,0DAAa;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI,mCAAC;AACL;;AAEA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA,KAAK,mCAAC;AACN;AACA;AACA,GAAG;AACH;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,iBAAiB;AAC1C;AACA,IAAI;;AAEJ,2BAA2B,iBAAiB;AAC5C;AACA;AACA,MAAM,kCAAkC;AACxC;AACA,IAAI;AACJ;AACA,IAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,EAAE,mCAAC,WAAW,eAAe;;AAE7B;AACA;AACA,EAAE,mCAAC;AACH,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,eAAe;AAC3B,YAAY,eAAe;AAC3B,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD,YAAY,2CAAS;AACrB,YAAY,2CAAS;;AAErB,wBAAwB,iBAAiB;AACzC;AACA;AACA,kBAAkB,2CAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA,kBAAkB,2CAAS;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,oBAAoB;AAChC,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAAa;AAC7B;AACA,cAAc,iBAAiB;AAC/B,iBAAiB,iBAAiB;AAClC,eAAe,iBAAiB;AAChC;AACA;;AAEA;AACA;AACA;AACA,YAAY,oBAAoB;AAChC,YAAY,oBAAoB;AAChC,YAAY,oBAAoB;AAChC,YAAY,oBAAoB;AAChC,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iBAAiB;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAM;AACN,GAAG,6BAA6B;AAChC,GAAG;AACH;AACA,CAAC,mEAAsB;AACvB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sCAAsC,QAAQ;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH,EAAE;;AAEF,6EAAgC;AAChC;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC,QAAQ;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;;;AAIF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,mEAAsB;AACxC,wBAAwB,yEAA4B;;AAEpD;AACA;AACA,EAAE,kEAAqB,MAAM,0DAAa;AAC1C,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,0DAAa;AACjC,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG,kEAAqB,MAAM,0DAAa;AAC3C;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,eAAe,0DAAa;AAC5B;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,0DAAa;AACjC,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,0DAAa;;AAE1C;;AAEA;AACA,6BAA6B,0DAAa;AAC1C;AACA,GAAG;AACH,EAAE;;;;AAIF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,EAAE,mCAAC;AACH,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,mBAAmB,0DAAa;;AAEhC,EAAE,mCAAC;AACH,EAAE,mCAAC;;AAEH;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,GAAG,mCAAC;AACJ;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;;AAGF;AACA;;AAEA;AACA;AACA;AACA,EAAE,mCAAC;AACH,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;;AAEA,gBAAgB,0DAAa;AAC7B;;AAEA,EAAE,mCAAC;AACH,EAAE,mCAAC;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,mCAAC;AACL;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG,mCAAC;AACJ;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA,EAAE;;;;AAIF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM,2CAAS,gDAAgD,iBAAiB;AAChF;AACA;;AAEA,MAAM,2CAAS,sDAAsD,iBAAiB;AACtF;AACA;;AAEA,MAAM,2CAAS,kDAAkD,iBAAiB;AAClF;AACA;;AAEA;AACA;;AAEA;;AAEA,0CAAQ,EAAE,kEAAqB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,iBAAiB;AAC5C,8BAA8B,iBAAiB;AAC/C,4BAA4B,iBAAiB;;AAE7C;AACA,KAAK;;AAEL;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,2BAA2B,iBAAiB;AAC5C,8BAA8B,iBAAiB;AAC/C,4BAA4B,iBAAiB;;AAE7C;AACA,KAAK;;AAEL;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yEAA4B;;AAE1C;AACA,KAAK,wEAA2B;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,IAAI,sEAAyB;;AAE7B;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF,wCAAM;AACN;;AAEA,CAAC,kEAAqB;AACtB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,EAAE;;;AAGF,uDAAqB,GAAG,6DAAgB;;AAExC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAC;AACD;AACA;AACA;;AAEA,CAAC,kEAAqB,MAAM,0DAAa;AACzC,EAAE;;;AAGF,iEAAe,sDAAS,EAAC","sources":["webpack://wordpress-manager/./node_modules/datatables.net-searchpanes-bs5/js/searchPanes.bootstrap5.mjs","webpack://wordpress-manager/./node_modules/datatables.net-searchpanes/js/dataTables.searchPanes.mjs","webpack://wordpress-manager/./node_modules/datatables.net-select-bs5/js/select.bootstrap5.mjs","webpack://wordpress-manager/./node_modules/datatables.net-select/js/dataTables.select.mjs"],"sourcesContent":["/*! Bootstrap 5 integration for DataTables' SearchPanes\n * © SpryMedia Ltd - datatables.net/license\n */\n\nimport $ from 'jquery';\nimport DataTable from 'datatables.net-bs5';\nimport SearchPanes from 'datatables.net-searchpanes';\n\n$.extend(true, DataTable.SearchPane.classes, {\n    buttonGroup: 'btn-group',\n    disabledButton: 'disabled',\n    narrow: 'col',\n    pane: {\n        container: 'table'\n    },\n    paneButton: 'btn btn-light',\n    pill: 'badge rounded-pill bg-secondary',\n    search: 'form-control search',\n    table: 'table table-sm table-borderless',\n    topRow: 'dtsp-topRow'\n});\n$.extend(true, DataTable.SearchPanes.classes, {\n    clearAll: 'dtsp-clearAll btn btn-light',\n    collapseAll: 'dtsp-collapseAll btn btn-light',\n    container: 'dtsp-searchPanes',\n    disabledButton: 'disabled',\n    panes: 'dtsp-panes dtsp-panesContainer',\n    search: DataTable.SearchPane.classes.search,\n    showAll: 'dtsp-showAll btn btn-light',\n    title: 'dtsp-title',\n    titleRow: 'dtsp-titleRow'\n});\n\n\nexport default DataTable;\n","/*! SearchPanes 2.1.2\n * © SpryMedia Ltd - datatables.net/license\n */\n\nimport $ from 'jquery';\nimport DataTable from 'datatables.net';\n\n(function () {\n    'use strict';\n\n    var $$5;\n    var dataTable$2;\n    function setJQuery$4(jq) {\n        $$5 = jq;\n        dataTable$2 = jq.fn.dataTable;\n    }\n    var SearchPane = /** @class */ (function () {\n        /**\n         * Creates the panes, sets up the search function\n         *\n         * @param paneSettings The settings for the searchPanes\n         * @param opts The options for the default features\n         * @param index the index of the column for this pane\n         * @param panesContainer The overall container for SearchPanes that this pane will be attached to\n         * @param panes The custom pane settings if this is a custom pane\n         * @returns {object} the pane that has been created, including the table and the index of the pane\n         */\n        function SearchPane(paneSettings, opts, index, panesContainer, panes) {\n            var _this = this;\n            if (panes === void 0) { panes = null; }\n            // Check that the required version of DataTables is included\n            if (!dataTable$2 || !dataTable$2.versionCheck || !dataTable$2.versionCheck('1.10.0')) {\n                throw new Error('SearchPane requires DataTables 1.10 or newer');\n            }\n            // Check that Select is included\n            // eslint-disable-next-line no-extra-parens\n            if (!dataTable$2.select) {\n                throw new Error('SearchPane requires Select');\n            }\n            var table = new dataTable$2.Api(paneSettings);\n            this.classes = $$5.extend(true, {}, SearchPane.classes);\n            // Get options from user\n            this.c = $$5.extend(true, {}, SearchPane.defaults, opts, panes);\n            if (opts && opts.hideCount && opts.viewCount === undefined) {\n                this.c.viewCount = !this.c.hideCount;\n            }\n            var rowLength = table.columns().eq(0).toArray().length;\n            this.s = {\n                colExists: index < rowLength,\n                colOpts: undefined,\n                customPaneSettings: panes,\n                displayed: false,\n                dt: table,\n                dtPane: undefined,\n                firstSet: true,\n                index: index,\n                indexes: [],\n                listSet: false,\n                name: undefined,\n                rowData: {\n                    arrayFilter: [],\n                    arrayOriginal: [],\n                    bins: {},\n                    binsOriginal: {},\n                    filterMap: new Map(),\n                    totalOptions: 0\n                },\n                scrollTop: 0,\n                searchFunction: undefined,\n                selections: [],\n                serverSelect: [],\n                serverSelecting: false,\n                tableLength: null,\n                updating: false\n            };\n            this.s.colOpts = this.s.colExists ? this._getOptions() : this._getBonusOptions();\n            this.dom = {\n                buttonGroup: $$5('<div/>').addClass(this.classes.buttonGroup),\n                clear: $$5('<button type=\"button\">&#215;</button>')\n                    .attr('disabled', 'true')\n                    .addClass(this.classes.disabledButton)\n                    .addClass(this.classes.paneButton)\n                    .addClass(this.classes.clearButton)\n                    .html(this.s.dt.i18n('searchPanes.clearPane', this.c.i18n.clearPane)),\n                collapseButton: $$5('<button type=\"button\"><span class=\"' + this.classes.caret + '\">&#x5e;</span></button>')\n                    .addClass(this.classes.paneButton)\n                    .addClass(this.classes.collapseButton),\n                container: $$5('<div/>')\n                    .addClass(this.classes.container)\n                    .addClass(this.s.colOpts.className)\n                    .addClass(this.classes.layout +\n                    (parseInt(this.c.layout.split('-')[1], 10) < 10 ?\n                        this.c.layout :\n                        this.c.layout.split('-')[0] + '-9'))\n                    .addClass(this.s.customPaneSettings && this.s.customPaneSettings.className\n                    ? this.s.customPaneSettings.className\n                    : ''),\n                countButton: $$5('<button type=\"button\"></button>')\n                    .addClass(this.classes.paneButton)\n                    .addClass(this.classes.countButton),\n                dtP: $$5('<table><thead><tr><th>' +\n                    (this.s.colExists\n                        ? $$5(this.s.dt.column(this.s.index).header()).text()\n                        : this.s.customPaneSettings.header || 'Custom Pane') + '</th><th/></tr></thead></table>'),\n                lower: $$5('<div/>').addClass(this.classes.subRow2).addClass(this.classes.narrowButton),\n                nameButton: $$5('<button type=\"button\"></button>')\n                    .addClass(this.classes.paneButton)\n                    .addClass(this.classes.nameButton),\n                panesContainer: panesContainer,\n                searchBox: $$5('<input/>').addClass(this.classes.paneInputButton).addClass(this.classes.search),\n                searchButton: $$5('<button type = \"button\"/>')\n                    .addClass(this.classes.searchIcon)\n                    .addClass(this.classes.paneButton),\n                searchCont: $$5('<div/>').addClass(this.classes.searchCont),\n                searchLabelCont: $$5('<div/>').addClass(this.classes.searchLabelCont),\n                topRow: $$5('<div/>').addClass(this.classes.topRow),\n                upper: $$5('<div/>').addClass(this.classes.subRow1).addClass(this.classes.narrowSearch)\n            };\n            // Set the value of name incase ordering is desired\n            if (this.s.colOpts.name) {\n                this.s.name = this.s.colOpts.name;\n            }\n            else if (this.s.customPaneSettings && this.s.customPaneSettings.name) {\n                this.s.name = this.s.customPaneSettings.name;\n            }\n            else {\n                this.s.name = this.s.colExists ?\n                    $$5(this.s.dt.column(this.s.index).header()).text() :\n                    this.s.customPaneSettings.header || 'Custom Pane';\n            }\n            var tableNode = this.s.dt.table(0).node();\n            // Custom search function for table\n            this.s.searchFunction = function (settings, searchData, dataIndex) {\n                // If no data has been selected then show all\n                if (_this.s.selections.length === 0) {\n                    return true;\n                }\n                if (settings.nTable !== tableNode) {\n                    return true;\n                }\n                var filter = null;\n                if (_this.s.colExists) {\n                    // Get the current filtered data\n                    filter = searchData[_this.s.index];\n                    if (_this.s.colOpts.orthogonal.filter !== 'filter') {\n                        // get the filter value from the map\n                        filter = _this.s.rowData.filterMap.get(dataIndex);\n                        if (filter instanceof $$5.fn.dataTable.Api) {\n                            // eslint-disable-next-line no-extra-parens\n                            filter = filter.toArray();\n                        }\n                    }\n                }\n                return _this._search(filter, dataIndex);\n            };\n            $$5.fn.dataTable.ext.search.push(this.s.searchFunction);\n            // If the clear button for this pane is clicked clear the selections\n            if (this.c.clear) {\n                this.dom.clear.on('click.dtsp', function () {\n                    var searches = _this.dom.container.find('.' + _this.classes.search.replace(/\\s+/g, '.'));\n                    searches.each(function () {\n                        $$5(this).val('').trigger('input');\n                    });\n                    _this.clearPane();\n                });\n            }\n            // Sometimes the top row of the panes containing the search box and ordering buttons appears\n            //  weird if the width of the panes is lower than expected, this fixes the design.\n            // Equally this may occur when the table is resized.\n            this.s.dt.on('draw.dtsp', function () { return _this.adjustTopRow(); });\n            this.s.dt.on('buttons-action.dtsp', function () { return _this.adjustTopRow(); });\n            // When column-reorder is present and the columns are moved, it is necessary to\n            //  reassign all of the panes indexes to the new index of the column.\n            this.s.dt.on('column-reorder.dtsp', function (e, settings, details) {\n                _this.s.index = details.mapping[_this.s.index];\n            });\n            return this;\n        }\n        /**\n         * Adds a row to the panes table\n         *\n         * @param display the value to be displayed to the user\n         * @param filter the value to be filtered on when searchpanes is implemented\n         * @param shown the number of rows in the table that are currently visible matching this criteria\n         * @param total the total number of rows in the table that match this criteria\n         * @param sort the value to be sorted in the pane table\n         * @param type the value of which the type is to be derived from\n         */\n        SearchPane.prototype.addRow = function (display, filter, sort, type, className, total, shown) {\n            if (!total) {\n                total = this.s.rowData.bins[filter] ?\n                    this.s.rowData.bins[filter] :\n                    0;\n            }\n            if (!shown) {\n                shown = this._getShown(filter);\n            }\n            var index;\n            for (var _i = 0, _a = this.s.indexes; _i < _a.length; _i++) {\n                var entry = _a[_i];\n                if (entry.filter === filter) {\n                    index = entry.index;\n                }\n            }\n            if (index === undefined) {\n                index = this.s.indexes.length;\n                this.s.indexes.push({ filter: filter, index: index });\n            }\n            return this.s.dtPane.row.add({\n                className: className,\n                display: display !== '' ?\n                    display :\n                    this.emptyMessage(),\n                filter: filter,\n                index: index,\n                shown: shown,\n                sort: sort,\n                total: total,\n                type: type\n            });\n        };\n        /**\n         * Adjusts the layout of the top row when the screen is resized\n         */\n        SearchPane.prototype.adjustTopRow = function () {\n            var subContainers = this.dom.container.find('.' + this.classes.subRowsContainer.replace(/\\s+/g, '.'));\n            var subRow1 = this.dom.container.find('.' + this.classes.subRow1.replace(/\\s+/g, '.'));\n            var subRow2 = this.dom.container.find('.' + this.classes.subRow2.replace(/\\s+/g, '.'));\n            var topRow = this.dom.container.find('.' + this.classes.topRow.replace(/\\s+/g, '.'));\n            // If the width is 0 then it is safe to assume that the pane has not yet been displayed.\n            //  Even if it has, if the width is 0 it won't make a difference if it has the narrow class or not\n            if (($$5(subContainers[0]).width() < 252 || $$5(topRow[0]).width() < 252) && $$5(subContainers[0]).width() !== 0) {\n                $$5(subContainers[0]).addClass(this.classes.narrow);\n                $$5(subRow1[0]).addClass(this.classes.narrowSub).removeClass(this.classes.narrowSearch);\n                $$5(subRow2[0]).addClass(this.classes.narrowSub).removeClass(this.classes.narrowButton);\n            }\n            else {\n                $$5(subContainers[0]).removeClass(this.classes.narrow);\n                $$5(subRow1[0]).removeClass(this.classes.narrowSub).addClass(this.classes.narrowSearch);\n                $$5(subRow2[0]).removeClass(this.classes.narrowSub).addClass(this.classes.narrowButton);\n            }\n        };\n        /**\n         * In the case of a rebuild there is potential for new data to have been included or removed\n         * so all of the rowData must be reset as a precaution.\n         */\n        SearchPane.prototype.clearData = function () {\n            this.s.rowData = {\n                arrayFilter: [],\n                arrayOriginal: [],\n                bins: {},\n                binsOriginal: {},\n                filterMap: new Map(),\n                totalOptions: 0\n            };\n        };\n        /**\n         * Clear the selections in the pane\n         */\n        SearchPane.prototype.clearPane = function () {\n            // Deselect all rows which are selected and update the table and filter count.\n            this.s.dtPane.rows({ selected: true }).deselect();\n            this.updateTable();\n            return this;\n        };\n        /**\n         * Collapses the pane so that only the header is displayed\n         */\n        SearchPane.prototype.collapse = function () {\n            var _this = this;\n            if (!this.s.displayed ||\n                (\n                // If collapsing is disabled globally, and not enabled specifically for this column\n                !this.c.collapse && this.s.colOpts.collapse !== true ||\n                    // OR, collapsing could be enabled globally and this column specifically\n                    // is not to be collapsed.\n                    // We can't just take !this.s.colOpts.collapse here as if it is undefined\n                    // then the global should be used\n                    this.s.colOpts.collapse === false)) {\n                return;\n            }\n            $$5(this.s.dtPane.table().container()).addClass(this.classes.hidden);\n            this.dom.topRow.addClass(this.classes.bordered);\n            this.dom.nameButton.addClass(this.classes.disabledButton);\n            this.dom.countButton.addClass(this.classes.disabledButton);\n            this.dom.searchButton.addClass(this.classes.disabledButton);\n            this.dom.collapseButton.addClass(this.classes.rotated);\n            this.dom.topRow.one('click.dtsp', function () { return _this.show(); });\n            this.dom.topRow.trigger('collapse.dtsps');\n        };\n        /**\n         * Strips all of the SearchPanes elements from the document and turns all of the listeners for the buttons off\n         */\n        SearchPane.prototype.destroy = function () {\n            if (this.s.dtPane) {\n                this.s.dtPane.off('.dtsp');\n            }\n            this.s.dt.off('.dtsp');\n            this.dom.clear.off('.dtsp');\n            this.dom.nameButton.off('.dtsp');\n            this.dom.countButton.off('.dtsp');\n            this.dom.searchButton.off('.dtsp');\n            this.dom.collapseButton.off('.dtsp');\n            $$5(this.s.dt.table().node()).off('.dtsp');\n            this.dom.container.detach();\n            var searchIdx = $$5.fn.dataTable.ext.search.indexOf(this.s.searchFunction);\n            while (searchIdx !== -1) {\n                $$5.fn.dataTable.ext.search.splice(searchIdx, 1);\n                searchIdx = $$5.fn.dataTable.ext.search.indexOf(this.s.searchFunction);\n            }\n            // If the datatables have been defined for the panes then also destroy these\n            if (this.s.dtPane) {\n                this.s.dtPane.destroy();\n            }\n            this.s.listSet = false;\n        };\n        /**\n         * Getting the legacy message is a little complex due a legacy parameter\n         */\n        SearchPane.prototype.emptyMessage = function () {\n            var def = this.c.i18n.emptyMessage;\n            // Legacy parameter support\n            if (this.c.emptyMessage) {\n                def = this.c.emptyMessage;\n            }\n            // Override per column\n            if (this.s.colOpts.emptyMessage !== false && this.s.colOpts.emptyMessage !== null) {\n                def = this.s.colOpts.emptyMessage;\n            }\n            return this.s.dt.i18n('searchPanes.emptyMessage', def);\n        };\n        /**\n         * Updates the number of filters that have been applied in the title\n         */\n        SearchPane.prototype.getPaneCount = function () {\n            return this.s.dtPane ?\n                this.s.dtPane.rows({ selected: true }).data().toArray().length :\n                0;\n        };\n        /**\n         * Rebuilds the panes from the start having deleted the old ones\n         *\n         * @param? dataIn data to be used in buildPane\n         * @param? maintainSelection Whether the current selections are to be maintained over rebuild\n         */\n        SearchPane.prototype.rebuildPane = function (dataIn, maintainSelection) {\n            if (dataIn === void 0) { dataIn = null; }\n            if (maintainSelection === void 0) { maintainSelection = false; }\n            this.clearData();\n            var selectedRows = [];\n            this.s.serverSelect = [];\n            var prevEl = null;\n            // When rebuilding strip all of the HTML Elements out of the container and start from scratch\n            if (this.s.dtPane) {\n                if (maintainSelection) {\n                    if (!this.s.dt.page.info().serverSide) {\n                        selectedRows = this.s.dtPane.rows({ selected: true }).data().toArray();\n                    }\n                    else {\n                        this.s.serverSelect = this.s.dtPane.rows({ selected: true }).data().toArray();\n                    }\n                }\n                this.s.dtPane.clear().destroy();\n                prevEl = this.dom.container.prev();\n                this.destroy();\n                this.s.dtPane = undefined;\n                $$5.fn.dataTable.ext.search.push(this.s.searchFunction);\n            }\n            this.dom.container.removeClass(this.classes.hidden);\n            this.s.displayed = false;\n            this._buildPane(!this.s.dt.page.info().serverSide ?\n                selectedRows :\n                this.s.serverSelect, dataIn, prevEl);\n            return this;\n        };\n        /**\n         * Resizes the pane based on the layout that is passed in\n         *\n         * @param layout the layout to be applied to this pane\n         */\n        SearchPane.prototype.resize = function (layout) {\n            this.c.layout = layout;\n            this.dom.container\n                .removeClass()\n                .addClass(this.classes.show)\n                .addClass(this.classes.container)\n                .addClass(this.s.colOpts.className)\n                .addClass(this.classes.layout +\n                (parseInt(layout.split('-')[1], 10) < 10 ?\n                    layout :\n                    layout.split('-')[0] + '-9'))\n                .addClass(this.s.customPaneSettings !== null && this.s.customPaneSettings.className\n                ? this.s.customPaneSettings.className\n                : '');\n            this.adjustTopRow();\n        };\n        /**\n         * Sets the listeners for the pane.\n         *\n         * Having it in it's own function makes it easier to only set them once\n         */\n        SearchPane.prototype.setListeners = function () {\n            var _this = this;\n            if (!this.s.dtPane) {\n                return;\n            }\n            // When an item is selected on the pane, add these to the array which holds selected items.\n            // Custom search will perform.\n            this.s.dtPane.off('select.dtsp').on('select.dtsp', function () {\n                clearTimeout(_this.s.deselectTimeout);\n                _this._updateSelection(!_this.s.updating);\n                _this.dom.clear.removeClass(_this.classes.disabledButton).removeAttr('disabled');\n            });\n            // When an item is deselected on the pane, re add the currently selected items to the array\n            // which holds selected items. Custom search will be performed.\n            this.s.dtPane.off('deselect.dtsp').on('deselect.dtsp', function () {\n                _this.s.deselectTimeout = setTimeout(function () {\n                    _this._updateSelection(true);\n                    if (_this.s.dtPane.rows({ selected: true }).data().toArray().length === 0) {\n                        _this.dom.clear.addClass(_this.classes.disabledButton).attr('disabled', 'true');\n                    }\n                }, 50);\n            });\n            // If we attempty to turn off this event then it will ruin behaviour in other panes\n            //  so need to make sure that it is only done once\n            if (this.s.firstSet) {\n                this.s.firstSet = false;\n                // When saving the state store all of the selected rows for preselection next time around\n                this.s.dt.on('stateSaveParams.dtsp', function (e, settings, data) {\n                    // If the data being passed in is empty then state clear must have occured\n                    // so clear the panes state as well\n                    if ($$5.isEmptyObject(data)) {\n                        _this.s.dtPane.state.clear();\n                        return;\n                    }\n                    var bins;\n                    var order;\n                    var selected = [];\n                    var collapsed;\n                    var searchTerm;\n                    var arrayFilter;\n                    // Get all of the data needed for the state save from the pane\n                    if (_this.s.dtPane) {\n                        selected = _this.s.dtPane\n                            .rows({ selected: true })\n                            .data()\n                            .map(function (item) { return item.filter.toString(); })\n                            .toArray();\n                        searchTerm = _this.dom.searchBox.val();\n                        order = _this.s.dtPane.order();\n                        bins = _this.s.rowData.binsOriginal;\n                        arrayFilter = _this.s.rowData.arrayOriginal;\n                        collapsed = _this.dom.collapseButton.hasClass(_this.classes.rotated);\n                    }\n                    if (data.searchPanes === undefined) {\n                        data.searchPanes = {};\n                    }\n                    if (data.searchPanes.panes === undefined) {\n                        data.searchPanes.panes = [];\n                    }\n                    for (var i = 0; i < data.searchPanes.panes.length; i++) {\n                        if (data.searchPanes.panes[i].id === _this.s.index) {\n                            data.searchPanes.panes.splice(i, 1);\n                            i--;\n                        }\n                    }\n                    // Add the panes data to the state object\n                    data.searchPanes.panes.push({\n                        arrayFilter: arrayFilter,\n                        bins: bins,\n                        collapsed: collapsed,\n                        id: _this.s.index,\n                        order: order,\n                        searchTerm: searchTerm,\n                        selected: selected\n                    });\n                });\n            }\n            this.s.dtPane.off('user-select.dtsp').on('user-select.dtsp', function (e, _dt, type, cell, originalEvent) {\n                originalEvent.stopPropagation();\n            });\n            this.s.dtPane.off('draw.dtsp').on('draw.dtsp', function () { return _this.adjustTopRow(); });\n            // When the button to order by the name of the options is clicked then\n            //  change the ordering to whatever it isn't currently\n            this.dom.nameButton.off('click.dtsp').on('click.dtsp', function () {\n                var currentOrder = _this.s.dtPane.order()[0][1];\n                _this.s.dtPane.order([0, currentOrder === 'asc' ? 'desc' : 'asc']).draw();\n                // This state save is required so that the ordering of the panes is maintained\n                _this.s.dt.state.save();\n            });\n            // When the button to order by the number of entries in the column is clicked then\n            //  change the ordering to whatever it isn't currently\n            this.dom.countButton.off('click.dtsp').on('click.dtsp', function () {\n                var currentOrder = _this.s.dtPane.order()[0][1];\n                _this.s.dtPane.order([1, currentOrder === 'asc' ? 'desc' : 'asc']).draw();\n                // This state save is required so that the ordering of the panes is maintained\n                _this.s.dt.state.save();\n            });\n            // When the button to order by the number of entries in the column is clicked then\n            //  change the ordering to whatever it isn't currently\n            this.dom.collapseButton.off('click.dtsp').on('click.dtsp', function (e) {\n                e.stopPropagation();\n                var container = $$5(_this.s.dtPane.table().container());\n                // Toggle the classes\n                container.toggleClass(_this.classes.hidden);\n                _this.dom.topRow.toggleClass(_this.classes.bordered);\n                _this.dom.nameButton.toggleClass(_this.classes.disabledButton);\n                _this.dom.countButton.toggleClass(_this.classes.disabledButton);\n                _this.dom.searchButton.toggleClass(_this.classes.disabledButton);\n                _this.dom.collapseButton.toggleClass(_this.classes.rotated);\n                if (container.hasClass(_this.classes.hidden)) {\n                    _this.dom.topRow.on('click.dtsp', function () { return _this.dom.collapseButton.click(); });\n                }\n                else {\n                    _this.dom.topRow.off('click.dtsp');\n                }\n                _this.s.dt.state.save();\n                _this.dom.topRow.trigger('collapse.dtsps');\n            });\n            // When the clear button is clicked reset the pane\n            this.dom.clear.off('click.dtsp').on('click.dtsp', function () {\n                var searches = _this.dom.container.find('.' + _this.classes.search.replace(/ /g, '.'));\n                searches.each(function () {\n                    // set the value of the search box to be an empty string and then search on that, effectively reseting\n                    $$5(this).val('').trigger('input');\n                });\n                _this.clearPane();\n            });\n            // When the search button is clicked then draw focus to the search box\n            this.dom.searchButton.off('click.dtsp').on('click.dtsp', function () { return _this.dom.searchBox.focus(); });\n            // When a character is inputted into the searchbox search the pane for matching values.\n            // Doing it this way means that no button has to be clicked to trigger a search, it is done asynchronously\n            this.dom.searchBox.off('click.dtsp').on('input.dtsp', function () {\n                var searchval = _this.dom.searchBox.val();\n                _this.s.dtPane.search(searchval).draw();\n                if (typeof searchval === 'string' &&\n                    (searchval.length > 0 ||\n                        searchval.length === 0 && _this.s.dtPane.rows({ selected: true }).data().toArray().length > 0)) {\n                    _this.dom.clear.removeClass(_this.classes.disabledButton).removeAttr('disabled');\n                }\n                else {\n                    _this.dom.clear.addClass(_this.classes.disabledButton).attr('disabled', 'true');\n                }\n                // This state save is required so that the searching on the panes is maintained\n                _this.s.dt.state.save();\n            });\n            this.s.dtPane.select.style(this.s.colOpts.dtOpts && this.s.colOpts.dtOpts.select && this.s.colOpts.dtOpts.select.style\n                ? this.s.colOpts.dtOpts.select.style\n                : this.c.dtOpts && this.c.dtOpts.select && this.c.dtOpts.select.style\n                    ? this.c.dtOpts.select.style\n                    : 'os');\n        };\n        /**\n         * Populates the SearchPane based off of the data that has been recieved from the server\n         *\n         * This method is overriden by SearchPaneST\n         *\n         * @param dataIn The data that has been sent from the server\n         */\n        SearchPane.prototype._serverPopulate = function (dataIn) {\n            if (dataIn.tableLength) {\n                this.s.tableLength = dataIn.tableLength;\n                this.s.rowData.totalOptions = this.s.tableLength;\n            }\n            else if (this.s.tableLength === null || this.s.dt.rows()[0].length > this.s.tableLength) {\n                this.s.tableLength = this.s.dt.rows()[0].length;\n                this.s.rowData.totalOptions = this.s.tableLength;\n            }\n            var colTitle = this.s.dt.column(this.s.index).dataSrc();\n            // If there is SP data for this column add it to the data array and bin\n            if (dataIn.searchPanes.options[colTitle]) {\n                for (var _i = 0, _a = dataIn.searchPanes.options[colTitle]; _i < _a.length; _i++) {\n                    var dataPoint = _a[_i];\n                    this.s.rowData.arrayFilter.push({\n                        display: dataPoint.label,\n                        filter: dataPoint.value,\n                        sort: dataPoint.label,\n                        type: dataPoint.label\n                    });\n                    this.s.rowData.bins[dataPoint.value] = dataPoint.total;\n                }\n            }\n            var binLength = Object.keys(this.s.rowData.bins).length;\n            var uniqueRatio = this._uniqueRatio(binLength, this.s.tableLength);\n            // Don't show the pane if there isnt enough variance in the data, or there is only 1 entry for that pane\n            if (this.s.displayed === false &&\n                ((this.s.colOpts.show === undefined && this.s.colOpts.threshold === null ?\n                    uniqueRatio > this.c.threshold :\n                    uniqueRatio > this.s.colOpts.threshold) ||\n                    this.s.colOpts.show !== true && binLength <= 1)) {\n                this.dom.container.addClass(this.classes.hidden);\n                this.s.displayed = false;\n                return;\n            }\n            // Store the original data\n            this.s.rowData.arrayOriginal = this.s.rowData.arrayFilter;\n            this.s.rowData.binsOriginal = this.s.rowData.bins;\n            // Flag this pane as being displayed\n            this.s.displayed = true;\n        };\n        /**\n         * Expands the pane from the collapsed state\n         */\n        SearchPane.prototype.show = function () {\n            if (!this.s.displayed) {\n                return;\n            }\n            this.dom.topRow.removeClass(this.classes.bordered);\n            this.dom.nameButton.removeClass(this.classes.disabledButton);\n            this.dom.countButton.removeClass(this.classes.disabledButton);\n            this.dom.searchButton.removeClass(this.classes.disabledButton);\n            this.dom.collapseButton.removeClass(this.classes.rotated);\n            $$5(this.s.dtPane.table().container()).removeClass(this.classes.hidden);\n            this.dom.topRow.trigger('collapse.dtsps');\n        };\n        /**\n         * Finds the ratio of the number of different options in the table to the number of rows\n         *\n         * @param bins the number of different options in the table\n         * @param rowCount the total number of rows in the table\n         * @returns {number} returns the ratio\n         */\n        SearchPane.prototype._uniqueRatio = function (bins, rowCount) {\n            if (rowCount > 0 &&\n                (this.s.rowData.totalOptions > 0 && !this.s.dt.page.info().serverSide ||\n                    this.s.dt.page.info().serverSide && this.s.tableLength > 0)) {\n                return bins / this.s.rowData.totalOptions;\n            }\n            return 1;\n        };\n        /**\n         * Updates the panes if one of the options to do so has been set to true\n         * rather than the filtered message when using viewTotal.\n         */\n        SearchPane.prototype.updateTable = function () {\n            var selectedRows = this.s.dtPane.rows({ selected: true }).data().toArray().map(function (el) { return el.filter; });\n            this.s.selections = selectedRows;\n            this._searchExtras();\n        };\n        /**\n         * Adds the custom options to the pane\n         *\n         * @returns {Array} Returns the array of rows which have been added to the pane\n         */\n        SearchPane.prototype._getComparisonRows = function () {\n            // Find the appropriate options depending on whether this is a pane for a specific column or a custom pane\n            var options = this.s.colOpts.options\n                ? this.s.colOpts.options\n                : this.s.customPaneSettings && this.s.customPaneSettings.options\n                    ? this.s.customPaneSettings.options\n                    : undefined;\n            if (options === undefined) {\n                return;\n            }\n            var allRows = this.s.dt.rows();\n            var tableValsTotal = allRows.data().toArray();\n            var rows = [];\n            // Clear all of the other rows from the pane, only custom options are to be displayed when they are defined\n            this.s.dtPane.clear();\n            this.s.indexes = [];\n            for (var _i = 0, options_1 = options; _i < options_1.length; _i++) {\n                var comp = options_1[_i];\n                // Initialise the object which is to be placed in the row\n                var insert = comp.label !== '' ?\n                    comp.label :\n                    this.emptyMessage();\n                var comparisonObj = {\n                    className: comp.className,\n                    display: insert,\n                    filter: typeof comp.value === 'function' ? comp.value : [],\n                    sort: insert,\n                    total: 0,\n                    type: insert\n                };\n                // If a custom function is in place\n                if (typeof comp.value === 'function') {\n                    // Count the number of times the function evaluates to true for the original data in the Table\n                    for (var i = 0; i < tableValsTotal.length; i++) {\n                        if (comp.value.call(this.s.dt, tableValsTotal[i], allRows[0][i])) {\n                            comparisonObj.total++;\n                        }\n                    }\n                    // Update the comparisonObj\n                    if (typeof comparisonObj.filter !== 'function') {\n                        comparisonObj.filter.push(comp.filter);\n                    }\n                }\n                rows.push(this.addRow(comparisonObj.display, comparisonObj.filter, comparisonObj.sort, comparisonObj.type, comparisonObj.className, comparisonObj.total));\n            }\n            return rows;\n        };\n        SearchPane.prototype._getMessage = function (row) {\n            return this.s.dt.i18n('searchPanes.count', this.c.i18n.count).replace(/{total}/g, row.total);\n        };\n        /**\n         * Overridden in SearchPaneViewTotal and SearchPaneCascade to get the number of times a specific value is shown\n         *\n         * Here it is blanked so that it takes no action\n         *\n         * @param filter The filter value\n         * @returns undefined\n         */\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        SearchPane.prototype._getShown = function (filter) {\n            return undefined;\n        };\n        /**\n         * Get's the pane config appropriate to this class\n         *\n         * @returns The config needed to create a pane of this type\n         */\n        SearchPane.prototype._getPaneConfig = function () {\n            var _this = this;\n            // eslint-disable-next-line no-extra-parens\n            var haveScroller = dataTable$2.Scroller;\n            var langOpts = this.s.dt.settings()[0].oLanguage;\n            langOpts.url = undefined;\n            langOpts.sUrl = undefined;\n            return {\n                columnDefs: [\n                    {\n                        className: 'dtsp-nameColumn',\n                        data: 'display',\n                        render: function (data, type, row) {\n                            if (type === 'sort') {\n                                return row.sort;\n                            }\n                            else if (type === 'type') {\n                                return row.type;\n                            }\n                            var message = _this._getMessage(row);\n                            // We are displaying the count in the same columne as the name of the search option.\n                            // This is so that there is not need to call columns.adjust()\n                            //  which in turn speeds up the code\n                            var pill = '<span class=\"' + _this.classes.pill + '\">' + message + '</span>';\n                            if (!_this.c.viewCount || !_this.s.colOpts.viewCount) {\n                                pill = '';\n                            }\n                            if (type === 'filter') {\n                                return typeof data === 'string' && data.match(/<[^>]*>/) !== null ?\n                                    data.replace(/<[^>]*>/g, '') :\n                                    data;\n                            }\n                            return '<div class=\"' + _this.classes.nameCont + '\"><span title=\"' +\n                                (typeof data === 'string' && data.match(/<[^>]*>/) !== null ?\n                                    data.replace(/<[^>]*>/g, '') :\n                                    data) +\n                                '\" class=\"' + _this.classes.name + '\">' +\n                                data + '</span>' +\n                                pill + '</div>';\n                        },\n                        targets: 0,\n                        // Accessing the private datatables property to set type based on the original table.\n                        // This is null if not defined by the user, meaning that automatic type detection\n                        //  would take place\n                        type: this.s.dt.settings()[0].aoColumns[this.s.index] ?\n                            this.s.dt.settings()[0].aoColumns[this.s.index]._sManualType :\n                            null\n                    },\n                    {\n                        className: 'dtsp-countColumn ' + this.classes.badgePill,\n                        data: 'total',\n                        searchable: false,\n                        targets: 1,\n                        visible: false\n                    }\n                ],\n                deferRender: true,\n                dom: 't',\n                info: false,\n                language: langOpts,\n                paging: haveScroller ? true : false,\n                scrollX: false,\n                scrollY: '200px',\n                scroller: haveScroller ? true : false,\n                select: true,\n                stateSave: this.s.dt.settings()[0].oFeatures.bStateSave ? true : false\n            };\n        };\n        /**\n         * This method allows for changes to the panes and table to be made when a selection or a deselection occurs\n         */\n        SearchPane.prototype._makeSelection = function () {\n            this.updateTable();\n            this.s.updating = true;\n            this.s.dt.draw(false);\n            this.s.updating = false;\n        };\n        /**\n         * Populates an array with all of the data for the table\n         *\n         * @param rowIdx The current row index to be compared\n         * @param arrayFilter The array that is to be populated with row Details\n         * @param settings The DataTable settings object\n         * @param bins The bins object that is to be populated with the row counts\n         */\n        SearchPane.prototype._populatePaneArray = function (rowIdx, arrayFilter, settings, bins) {\n            if (bins === void 0) { bins = this.s.rowData.bins; }\n            // Retrieve the rendered data from the cell using the fnGetCellData function\n            // rather than the cell().render API method for optimisation\n            if (typeof this.s.colOpts.orthogonal === 'string') {\n                var rendered = settings.oApi._fnGetCellData(settings, rowIdx, this.s.index, this.s.colOpts.orthogonal);\n                this.s.rowData.filterMap.set(rowIdx, rendered);\n                this._addOption(rendered, rendered, rendered, rendered, arrayFilter, bins);\n                this.s.rowData.totalOptions++;\n            }\n            else {\n                var filter = settings.oApi._fnGetCellData(settings, rowIdx, this.s.index, this.s.colOpts.orthogonal.search);\n                // Null and empty string are to be considered the same value\n                if (filter === null) {\n                    filter = '';\n                }\n                if (typeof filter === 'string') {\n                    filter = filter.replace(/<[^>]*>/g, '');\n                }\n                this.s.rowData.filterMap.set(rowIdx, filter);\n                if (!bins[filter]) {\n                    bins[filter] = 1;\n                    this._addOption(filter, settings.oApi._fnGetCellData(settings, rowIdx, this.s.index, this.s.colOpts.orthogonal.display), settings.oApi._fnGetCellData(settings, rowIdx, this.s.index, this.s.colOpts.orthogonal.sort), settings.oApi._fnGetCellData(settings, rowIdx, this.s.index, this.s.colOpts.orthogonal.type), arrayFilter, bins);\n                    this.s.rowData.totalOptions++;\n                }\n                else {\n                    bins[filter]++;\n                    this.s.rowData.totalOptions++;\n                }\n            }\n        };\n        /**\n         * Reloads all of the previous selects into the panes\n         *\n         * @param loadedFilter The loaded filters from a previous state\n         */\n        SearchPane.prototype._reloadSelect = function (loadedFilter) {\n            // If the state was not saved don't selected any\n            if (loadedFilter === undefined) {\n                return;\n            }\n            var idx;\n            // For each pane, check that the loadedFilter list exists and is not null,\n            // find the id of each search item and set it to be selected.\n            for (var i = 0; i < loadedFilter.searchPanes.panes.length; i++) {\n                if (loadedFilter.searchPanes.panes[i].id === this.s.index) {\n                    idx = i;\n                    break;\n                }\n            }\n            if (idx) {\n                var table = this.s.dtPane;\n                var rows = table.rows({ order: 'index' }).data().map(function (item) { return item.filter !== null ?\n                    item.filter.toString() :\n                    null; }).toArray();\n                for (var _i = 0, _a = loadedFilter.searchPanes.panes[idx].selected; _i < _a.length; _i++) {\n                    var filter = _a[_i];\n                    var id = -1;\n                    if (filter !== null) {\n                        id = rows.indexOf(filter.toString());\n                    }\n                    if (id > -1) {\n                        this.s.serverSelecting = true;\n                        table.row(id).select();\n                        this.s.serverSelecting = false;\n                    }\n                }\n            }\n        };\n        /**\n         * Notes the rows that have been selected within this pane and stores them internally\n         *\n         * @param notUpdating Whether the panes are updating themselves or not\n         */\n        SearchPane.prototype._updateSelection = function (notUpdating) {\n            var _this = this;\n            var settings = this.s.dt.settings()[0];\n            var oApi = settings.oApi;\n            var run = function () {\n                _this.s.scrollTop = $$5(_this.s.dtPane.table().node()).parent()[0].scrollTop;\n                if (_this.s.dt.page.info().serverSide && !_this.s.updating) {\n                    if (!_this.s.serverSelecting) {\n                        _this.s.serverSelect = _this.s.dtPane.rows({ selected: true }).data().toArray();\n                        _this.s.dt.draw(false);\n                    }\n                }\n                else if (notUpdating) {\n                    _this._makeSelection();\n                }\n                oApi._fnProcessingDisplay(settings, false);\n            };\n            // If the processing display is enabled, we need to allow the browser\n            // to draw it before performing our calculations\n            if (settings.oFeatures.bProcessing) {\n                oApi._fnProcessingDisplay(settings, true);\n                setTimeout(run, 1);\n            }\n            else {\n                run();\n            }\n        };\n        /**\n         * Takes in potentially undetected rows and adds them to the array if they are not yet featured\n         *\n         * @param filter the filter value of the potential row\n         * @param display the display value of the potential row\n         * @param sort the sort value of the potential row\n         * @param type the type value of the potential row\n         * @param arrayFilter the array to be populated\n         * @param bins the bins to be populated\n         */\n        SearchPane.prototype._addOption = function (filter, display, sort, type, arrayFilter, bins) {\n            // If the filter is an array then take a note of this, and add the elements to the arrayFilter array\n            if (Array.isArray(filter) || filter instanceof dataTable$2.Api) {\n                // Convert to an array so that we can work with it\n                if (filter instanceof dataTable$2.Api) {\n                    filter = filter.toArray();\n                    display = display.toArray();\n                }\n                if (filter.length === display.length) {\n                    for (var i = 0; i < filter.length; i++) {\n                        // If we haven't seen this row before add it\n                        if (!bins[filter[i]]) {\n                            bins[filter[i]] = 1;\n                            arrayFilter.push({\n                                display: display[i],\n                                filter: filter[i],\n                                sort: sort[i],\n                                type: type[i]\n                            });\n                        }\n                        // Otherwise just increment the count\n                        else {\n                            bins[filter[i]]++;\n                        }\n                        this.s.rowData.totalOptions++;\n                    }\n                    return;\n                }\n                throw new Error('display and filter not the same length');\n            }\n            // If the values were affected by othogonal data and are not an array then check if it is already present\n            else if (typeof this.s.colOpts.orthogonal === 'string') {\n                if (!bins[filter]) {\n                    bins[filter] = 1;\n                    arrayFilter.push({\n                        display: display,\n                        filter: filter,\n                        sort: sort,\n                        type: type\n                    });\n                    this.s.rowData.totalOptions++;\n                }\n                else {\n                    bins[filter]++;\n                    this.s.rowData.totalOptions++;\n                }\n            }\n            // Otherwise we must just be adding an option\n            else {\n                arrayFilter.push({\n                    display: display,\n                    filter: filter,\n                    sort: sort,\n                    type: type\n                });\n            }\n        };\n        /**\n         * Method to construct the actual pane.\n         *\n         * @param selectedRows previously selected Rows to be reselected\n         * @param dataIn Data that should be used to populate this pane\n         * @param prevEl Reference to the previous element, used to ensure insert is in the correct location\n         * @returns boolean to indicate whether this pane was the last one to have a selection made\n         */\n        SearchPane.prototype._buildPane = function (selectedRows, dataIn, prevEl) {\n            var _this = this;\n            if (selectedRows === void 0) { selectedRows = []; }\n            if (dataIn === void 0) { dataIn = null; }\n            if (prevEl === void 0) { prevEl = null; }\n            // Aliases\n            this.s.selections = [];\n            // Other Variables\n            var loadedFilter = this.s.dt.state.loaded();\n            // If the listeners have not been set yet then using the latest state may result in funny errors\n            if (this.s.listSet) {\n                loadedFilter = this.s.dt.state();\n            }\n            // If it is not a custom pane in place\n            if (this.s.colExists) {\n                var idx = -1;\n                if (loadedFilter && loadedFilter.searchPanes && loadedFilter.searchPanes.panes) {\n                    for (var i = 0; i < loadedFilter.searchPanes.panes.length; i++) {\n                        if (loadedFilter.searchPanes.panes[i].id === this.s.index) {\n                            idx = i;\n                            break;\n                        }\n                    }\n                }\n                // Perform checks that do not require populate pane to run\n                if ((this.s.colOpts.show === false ||\n                    this.s.colOpts.show !== undefined && this.s.colOpts.show !== true) &&\n                    idx === -1) {\n                    this.dom.container.addClass(this.classes.hidden);\n                    this.s.displayed = false;\n                    return false;\n                }\n                else if (this.s.colOpts.show === true || idx !== -1) {\n                    this.s.displayed = true;\n                }\n                if (!this.s.dt.page.info().serverSide &&\n                    (!dataIn ||\n                        !dataIn.searchPanes ||\n                        !dataIn.searchPanes.options)) {\n                    // Only run populatePane if the data has not been collected yet\n                    if (this.s.rowData.arrayFilter.length === 0) {\n                        this.s.rowData.totalOptions = 0;\n                        this._populatePane();\n                        this.s.rowData.arrayOriginal = this.s.rowData.arrayFilter;\n                        this.s.rowData.binsOriginal = this.s.rowData.bins;\n                    }\n                    var binLength = Object.keys(this.s.rowData.binsOriginal).length;\n                    var uniqueRatio = this._uniqueRatio(binLength, this.s.dt.rows()[0].length);\n                    // Don't show the pane if there isn't enough variance in the data, or there is only 1 entry\n                    //  for that pane\n                    if (this.s.displayed === false &&\n                        ((this.s.colOpts.show === undefined && this.s.colOpts.threshold === null ?\n                            uniqueRatio > this.c.threshold :\n                            uniqueRatio > this.s.colOpts.threshold) ||\n                            this.s.colOpts.show !== true && binLength <= 1)) {\n                        this.dom.container.addClass(this.classes.hidden);\n                        this.s.displayed = false;\n                        return;\n                    }\n                    this.dom.container.addClass(this.classes.show);\n                    this.s.displayed = true;\n                }\n                else if (dataIn && dataIn.searchPanes && dataIn.searchPanes.options) {\n                    this._serverPopulate(dataIn);\n                }\n            }\n            else {\n                this.s.displayed = true;\n            }\n            // If the variance is accceptable then display the search pane\n            this._displayPane();\n            if (!this.s.listSet) {\n                // Here, when the state is loaded if the data object on the original table is empty,\n                //  then a state.clear() must have occurred, so delete all of the panes tables state objects too.\n                this.dom.dtP.on('stateLoadParams.dtsp', function (e, settings, data) {\n                    if ($$5.isEmptyObject(_this.s.dt.state.loaded())) {\n                        $$5.each(data, function (index) {\n                            delete data[index];\n                        });\n                    }\n                });\n            }\n            // Add the container to the document in its original location\n            if (prevEl !== null && this.dom.panesContainer.has(prevEl).length > 0) {\n                this.dom.container.insertAfter(prevEl);\n            }\n            else {\n                this.dom.panesContainer.prepend(this.dom.container);\n            }\n            // Declare the datatable for the pane\n            var errMode = $$5.fn.dataTable.ext.errMode;\n            $$5.fn.dataTable.ext.errMode = 'none';\n            // eslint-disable-next-line no-extra-parens\n            this.s.dtPane = this.dom.dtP.DataTable($$5.extend(true, this._getPaneConfig(), this.c.dtOpts, this.s.colOpts ? this.s.colOpts.dtOpts : {}, this.s.colOpts.options || !this.s.colExists ?\n                {\n                    createdRow: function (row, data) {\n                        $$5(row).addClass(data.className);\n                    }\n                } :\n                undefined, this.s.customPaneSettings !== null && this.s.customPaneSettings.dtOpts ?\n                this.s.customPaneSettings.dtOpts :\n                {}, $$5.fn.dataTable.versionCheck('2')\n                ? {\n                    layout: {\n                        bottomLeft: null,\n                        bottomRight: null,\n                        topLeft: null,\n                        topRight: null\n                    }\n                }\n                : {}));\n            this.dom.dtP.addClass(this.classes.table);\n            // Getting column titles is a little messy\n            var headerText = 'Custom Pane';\n            if (this.s.customPaneSettings && this.s.customPaneSettings.header) {\n                headerText = this.s.customPaneSettings.header;\n            }\n            else if (this.s.colOpts.header) {\n                headerText = this.s.colOpts.header;\n            }\n            else if (this.s.colExists) {\n                headerText = $$5.fn.dataTable.versionCheck('2')\n                    ? this.s.dt.column(this.s.index).title()\n                    : this.s.dt.settings()[0].aoColumns[this.s.index].sTitle;\n            }\n            headerText = this._escapeHTML(headerText);\n            this.dom.searchBox.attr('placeholder', headerText);\n            // As the pane table is not in the document yet we must initialise select ourselves\n            // eslint-disable-next-line no-extra-parens\n            $$5.fn.dataTable.select.init(this.s.dtPane);\n            $$5.fn.dataTable.ext.errMode = errMode;\n            // If it is not a custom pane\n            if (this.s.colExists) {\n                // Add all of the search options to the pane\n                for (var i = 0, ien = this.s.rowData.arrayFilter.length; i < ien; i++) {\n                    if (this.s.dt.page.info().serverSide) {\n                        var row = this.addRow(this.s.rowData.arrayFilter[i].display, this.s.rowData.arrayFilter[i].filter, this.s.rowData.arrayFilter[i].sort, this.s.rowData.arrayFilter[i].type);\n                        for (var _i = 0, _a = this.s.serverSelect; _i < _a.length; _i++) {\n                            var option = _a[_i];\n                            if (option.filter === this.s.rowData.arrayFilter[i].filter) {\n                                this.s.serverSelecting = true;\n                                row.select();\n                                this.s.serverSelecting = false;\n                            }\n                        }\n                    }\n                    else if (!this.s.dt.page.info().serverSide && this.s.rowData.arrayFilter[i]) {\n                        this.addRow(this.s.rowData.arrayFilter[i].display, this.s.rowData.arrayFilter[i].filter, this.s.rowData.arrayFilter[i].sort, this.s.rowData.arrayFilter[i].type);\n                    }\n                    else if (!this.s.dt.page.info().serverSide) {\n                        // Just pass an empty string as the message will be calculated based on that in addRow()\n                        this.addRow('', '', '', '');\n                    }\n                }\n            }\n            // eslint-disable-next-line no-extra-parens\n            dataTable$2.select.init(this.s.dtPane);\n            // If there are custom options set or it is a custom pane then get them\n            if (this.s.colOpts.options ||\n                this.s.customPaneSettings && this.s.customPaneSettings.options) {\n                this._getComparisonRows();\n            }\n            // Display the pane\n            this.s.dtPane.draw();\n            this.s.dtPane.table().node().parentNode.scrollTop = this.s.scrollTop;\n            this.adjustTopRow();\n            this.setListeners();\n            this.s.listSet = true;\n            for (var _b = 0, selectedRows_1 = selectedRows; _b < selectedRows_1.length; _b++) {\n                var selection = selectedRows_1[_b];\n                if (selection) {\n                    for (var _c = 0, _d = this.s.dtPane.rows().indexes().toArray(); _c < _d.length; _c++) {\n                        var row = _d[_c];\n                        if (this.s.dtPane.row(row).data() &&\n                            selection.filter === this.s.dtPane.row(row).data().filter) {\n                            // If this is happening when serverSide processing is happening then\n                            //  different behaviour is needed\n                            if (this.s.dt.page.info().serverSide) {\n                                this.s.serverSelecting = true;\n                                this.s.dtPane.row(row).select();\n                                this.s.serverSelecting = false;\n                            }\n                            else {\n                                this.s.dtPane.row(row).select();\n                            }\n                        }\n                    }\n                }\n            }\n            //  If SSP and the table is ready, apply the search for the pane\n            if (this.s.dt.page.info().serverSide) {\n                this.s.dtPane.search(this.dom.searchBox.val()).draw();\n            }\n            if ((this.c.initCollapsed && this.s.colOpts.initCollapsed !== false ||\n                this.s.colOpts.initCollapsed) &&\n                (this.c.collapse && this.s.colOpts.collapse !== false ||\n                    this.s.colOpts.collapse)) {\n                // If the pane has not initialised yet then we need to wait for it to do so before collapsing\n                // Otherwise the container that the class is added to does not exist\n                if (this.s.dtPane.settings()[0]._bInitComplete) {\n                    this.collapse();\n                }\n                else {\n                    this.s.dtPane.one('init', function () { return _this.collapse(); });\n                }\n            }\n            // Reload the selection, searchbox entry and ordering from the previous state\n            // Need to check here if SSP that this is the first draw, otherwise it will infinite loop\n            if (loadedFilter &&\n                loadedFilter.searchPanes &&\n                loadedFilter.searchPanes.panes &&\n                (!dataIn ||\n                    dataIn.draw === 1)) {\n                this._reloadSelect(loadedFilter);\n                for (var _e = 0, _f = loadedFilter.searchPanes.panes; _e < _f.length; _e++) {\n                    var pane = _f[_e];\n                    if (pane.id === this.s.index) {\n                        // Save some time by only triggering an input if there is a value\n                        if (pane.searchTerm && pane.searchTerm.length > 0) {\n                            this.dom.searchBox.val(pane.searchTerm).trigger('input');\n                        }\n                        if (pane.order) {\n                            this.s.dtPane.order(pane.order).draw();\n                        }\n                        // Is the pane to be hidden or shown?\n                        if (pane.collapsed) {\n                            this.collapse();\n                        }\n                        else {\n                            this.show();\n                        }\n                    }\n                }\n            }\n            return true;\n        };\n        /**\n         * Appends all of the HTML elements to their relevant parent Elements\n         */\n        SearchPane.prototype._displayPane = function () {\n            // Empty everything to start again\n            this.dom.dtP.empty();\n            this.dom.topRow.empty().addClass(this.classes.topRow);\n            // If there are more than 3 columns defined then make there be a smaller gap between the panes\n            if (parseInt(this.c.layout.split('-')[1], 10) > 3) {\n                this.dom.container.addClass(this.classes.smallGap);\n            }\n            this.dom.topRow\n                .addClass(this.classes.subRowsContainer)\n                .append(this.dom.upper.append(this.dom.searchCont))\n                .append(this.dom.lower.append(this.dom.buttonGroup));\n            // If no selections have been made in the pane then disable the clear button\n            if (this.c.dtOpts.searching === false ||\n                this.s.colOpts.dtOpts && this.s.colOpts.dtOpts.searching === false ||\n                (!this.c.controls || !this.s.colOpts.controls) ||\n                this.s.customPaneSettings &&\n                    this.s.customPaneSettings.dtOpts &&\n                    this.s.customPaneSettings.dtOpts.searching !== undefined &&\n                    !this.s.customPaneSettings.dtOpts.searching) {\n                this.dom.searchBox\n                    .removeClass(this.classes.paneInputButton)\n                    .addClass(this.classes.disabledButton)\n                    .attr('disabled', 'true');\n            }\n            this.dom.searchBox.appendTo(this.dom.searchCont);\n            // Create the contents of the searchCont div. Worth noting that this function will change when using semantic ui\n            this._searchContSetup();\n            // If the clear button is allowed to show then display it\n            if (this.c.clear && this.c.controls && this.s.colOpts.controls) {\n                this.dom.clear.appendTo(this.dom.buttonGroup);\n            }\n            if (this.c.orderable && this.s.colOpts.orderable && this.c.controls && this.s.colOpts.controls) {\n                this.dom.nameButton.appendTo(this.dom.buttonGroup);\n            }\n            // If the count column is hidden then don't display the ordering button for it\n            if (this.c.viewCount &&\n                this.s.colOpts.viewCount &&\n                this.c.orderable &&\n                this.s.colOpts.orderable &&\n                this.c.controls &&\n                this.s.colOpts.controls) {\n                this.dom.countButton.appendTo(this.dom.buttonGroup);\n            }\n            if ((this.c.collapse && this.s.colOpts.collapse !== false ||\n                this.s.colOpts.collapse) &&\n                this.c.controls && this.s.colOpts.controls) {\n                this.dom.collapseButton.appendTo(this.dom.buttonGroup);\n            }\n            this.dom.container.prepend(this.dom.topRow).append(this.dom.dtP).show();\n        };\n        /**\n         * Escape html characters within a string\n         *\n         * @param txt the string to be escaped\n         * @returns the escaped string\n         */\n        SearchPane.prototype._escapeHTML = function (txt) {\n            return txt\n                .toString()\n                .replace(/&amp;/g, '&')\n                .replace(/&lt;/g, '<')\n                .replace(/&gt;/g, '>')\n                .replace(/&quot;/g, '\"');\n        };\n        /**\n         * Gets the options for the row for the customPanes\n         *\n         * @returns {object} The options for the row extended to include the options from the user.\n         */\n        SearchPane.prototype._getBonusOptions = function () {\n            // We need to reset the thresholds as if they have a value in colOpts then that value will be used\n            var defaultMutator = {\n                threshold: null\n            };\n            return $$5.extend(true, {}, SearchPane.defaults, defaultMutator, this.c ? this.c : {});\n        };\n        /**\n         * Gets the options for the row for the customPanes\n         *\n         * @returns {object} The options for the row extended to include the options from the user.\n         */\n        SearchPane.prototype._getOptions = function () {\n            var table = this.s.dt;\n            // We need to reset the thresholds as if they have a value in colOpts then that value will be used\n            var defaultMutator = {\n                collapse: null,\n                emptyMessage: false,\n                initCollapsed: null,\n                threshold: null\n            };\n            var columnOptions = table.settings()[0].aoColumns[this.s.index].searchPanes;\n            var colOpts = $$5.extend(true, {}, SearchPane.defaults, defaultMutator, columnOptions);\n            if (columnOptions && columnOptions.hideCount && columnOptions.viewCount === undefined) {\n                colOpts.viewCount = !columnOptions.hideCount;\n            }\n            return colOpts;\n        };\n        /**\n         * Fill the array with the values that are currently being displayed in the table\n         */\n        SearchPane.prototype._populatePane = function () {\n            this.s.rowData.arrayFilter = [];\n            this.s.rowData.bins = {};\n            var settings = this.s.dt.settings()[0];\n            if (!this.s.dt.page.info().serverSide) {\n                for (var _i = 0, _a = this.s.dt.rows().indexes().toArray(); _i < _a.length; _i++) {\n                    var index = _a[_i];\n                    this._populatePaneArray(index, this.s.rowData.arrayFilter, settings);\n                }\n            }\n        };\n        /**\n         * This method decides whether a row should contribute to the pane or not\n         *\n         * @param filter the value that the row is to be filtered on\n         * @param dataIndex the row index\n         */\n        SearchPane.prototype._search = function (filter, dataIndex) {\n            var colOpts = this.s.colOpts;\n            var table = this.s.dt;\n            // For each item selected in the pane, check if it is available in the cell\n            for (var _i = 0, _a = this.s.selections; _i < _a.length; _i++) {\n                var colSelect = _a[_i];\n                if (typeof colSelect === 'string' && typeof filter === 'string') {\n                    // The filter value will not have the &amp; in place but a &,\n                    // so we need to do a replace to make sure that they will match\n                    colSelect = this._escapeHTML(colSelect);\n                }\n                // if the filter is an array then is the column present in it\n                if (Array.isArray(filter)) {\n                    if (colOpts.combiner === 'and') {\n                        if (!filter.includes(colSelect)) {\n                            return false;\n                        }\n                    }\n                    else if (filter.includes(colSelect)) {\n                        return true;\n                    }\n                }\n                // if the filter is a function then does it meet the criteria of that function or not\n                else if (typeof colSelect === 'function') {\n                    if (colSelect.call(table, table.row(dataIndex).data(), dataIndex)) {\n                        if (colOpts.combiner === 'or') {\n                            return true;\n                        }\n                    }\n                    // If the combiner is an \"and\" then we need to check against all possible selections\n                    // so if it fails here then the and is not met and return false\n                    else if (colOpts.combiner === 'and') {\n                        return false;\n                    }\n                }\n                // otherwise if the two filter values are equal then return true\n                else if (filter === colSelect ||\n                    // Loose type checking incase number type in column comparing to a string\n                    // eslint-disable-next-line eqeqeq\n                    !(typeof filter === 'string' && filter.length === 0) && filter == colSelect ||\n                    colSelect === null && typeof filter === 'string' && filter === '') {\n                    return true;\n                }\n            }\n            // If the combiner is an and then we need to check against all possible selections\n            // so return true here if so because it would have returned false earlier if it had failed\n            if (colOpts.combiner === 'and') {\n                return true;\n            }\n            // Otherwise it hasn't matched with anything by this point so it must be false\n            return false;\n        };\n        /**\n         * Creates the contents of the searchCont div\n         *\n         * NOTE This is overridden when semantic ui styling in order to integrate the search button into the text box.\n         */\n        SearchPane.prototype._searchContSetup = function () {\n            if (this.c.controls && this.s.colOpts.controls) {\n                this.dom.searchButton.appendTo(this.dom.searchLabelCont);\n            }\n            if (!(this.c.dtOpts.searching === false ||\n                this.s.colOpts.dtOpts.searching === false ||\n                this.s.customPaneSettings &&\n                    this.s.customPaneSettings.dtOpts &&\n                    this.s.customPaneSettings.dtOpts.searching !== undefined &&\n                    !this.s.customPaneSettings.dtOpts.searching)) {\n                this.dom.searchLabelCont.appendTo(this.dom.searchCont);\n            }\n        };\n        /**\n         * Adds outline to the pane when a selection has been made\n         */\n        SearchPane.prototype._searchExtras = function () {\n            var updating = this.s.updating;\n            this.s.updating = true;\n            var filters = this.s.dtPane.rows({ selected: true }).data().pluck('filter').toArray();\n            var nullIndex = filters.indexOf(this.emptyMessage());\n            var container = $$5(this.s.dtPane.table().container());\n            // If null index is found then search for empty cells as a filter.\n            if (nullIndex > -1) {\n                filters[nullIndex] = '';\n            }\n            // If a filter has been applied then outline the respective pane, remove it when it no longer is.\n            if (filters.length > 0) {\n                container.addClass(this.classes.selected);\n            }\n            else if (filters.length === 0) {\n                container.removeClass(this.classes.selected);\n            }\n            this.s.updating = updating;\n        };\n        SearchPane.version = '2.1.2';\n        SearchPane.classes = {\n            bordered: 'dtsp-bordered',\n            buttonGroup: 'dtsp-buttonGroup',\n            buttonSub: 'dtsp-buttonSub',\n            caret: 'dtsp-caret',\n            clear: 'dtsp-clear',\n            clearAll: 'dtsp-clearAll',\n            clearButton: 'clearButton',\n            collapseAll: 'dtsp-collapseAll',\n            collapseButton: 'dtsp-collapseButton',\n            container: 'dtsp-searchPane',\n            countButton: 'dtsp-countButton',\n            disabledButton: 'dtsp-disabledButton',\n            hidden: 'dtsp-hidden',\n            hide: 'dtsp-hide',\n            layout: 'dtsp-',\n            name: 'dtsp-name',\n            nameButton: 'dtsp-nameButton',\n            nameCont: 'dtsp-nameCont',\n            narrow: 'dtsp-narrow',\n            paneButton: 'dtsp-paneButton',\n            paneInputButton: 'dtsp-paneInputButton',\n            pill: 'dtsp-pill',\n            rotated: 'dtsp-rotated',\n            search: 'dtsp-search',\n            searchCont: 'dtsp-searchCont',\n            searchIcon: 'dtsp-searchIcon',\n            searchLabelCont: 'dtsp-searchButtonCont',\n            selected: 'dtsp-selected',\n            smallGap: 'dtsp-smallGap',\n            subRow1: 'dtsp-subRow1',\n            subRow2: 'dtsp-subRow2',\n            subRowsContainer: 'dtsp-subRowsContainer',\n            title: 'dtsp-title',\n            topRow: 'dtsp-topRow'\n        };\n        // Define SearchPanes default options\n        SearchPane.defaults = {\n            clear: true,\n            collapse: true,\n            combiner: 'or',\n            container: function (dt) {\n                return dt.table().container();\n            },\n            controls: true,\n            dtOpts: {},\n            emptyMessage: null,\n            hideCount: false,\n            i18n: {\n                clearPane: '&times;',\n                count: '{total}',\n                emptyMessage: '<em>No data</em>'\n            },\n            initCollapsed: false,\n            layout: 'auto',\n            name: undefined,\n            orderable: true,\n            orthogonal: {\n                display: 'display',\n                filter: 'filter',\n                hideCount: false,\n                search: 'filter',\n                show: undefined,\n                sort: 'sort',\n                threshold: 0.6,\n                type: 'type',\n                viewCount: true\n            },\n            preSelect: [],\n            threshold: 0.6,\n            viewCount: true\n        };\n        return SearchPane;\n    }());\n\n    var __extends$4 = (window && window.__extends) || (function () {\n        var extendStatics = function (d, b) {\n            extendStatics = Object.setPrototypeOf ||\n                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n            return extendStatics(d, b);\n        };\n        return function (d, b) {\n            extendStatics(d, b);\n            function __() { this.constructor = d; }\n            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n        };\n    })();\n    var SearchPaneST = /** @class */ (function (_super) {\n        __extends$4(SearchPaneST, _super);\n        function SearchPaneST(paneSettings, opts, index, panesContainer, panes) {\n            return _super.call(this, paneSettings, opts, index, panesContainer, panes) || this;\n        }\n        /**\n         * Populates the SearchPane based off of the data that has been recieved from the server\n         *\n         * This method overrides SearchPane's _serverPopulate() method\n         *\n         * @param dataIn The data that has been sent from the server\n         */\n        SearchPaneST.prototype._serverPopulate = function (dataIn) {\n            this.s.rowData.binsShown = {};\n            this.s.rowData.arrayFilter = [];\n            if (dataIn.tableLength !== undefined) {\n                this.s.tableLength = dataIn.tableLength;\n                this.s.rowData.totalOptions = this.s.tableLength;\n            }\n            else if (this.s.tableLength === null || this.s.dt.rows()[0].length > this.s.tableLength) {\n                this.s.tableLength = this.s.dt.rows()[0].length;\n                this.s.rowData.totalOptions = this.s.tableLength;\n            }\n            var colTitle = this.s.dt.column(this.s.index).dataSrc();\n            // If there is SP data for this column add it to the data array and bin\n            if (dataIn.searchPanes.options[colTitle] !== undefined) {\n                for (var _i = 0, _a = dataIn.searchPanes.options[colTitle]; _i < _a.length; _i++) {\n                    var dataPoint = _a[_i];\n                    this.s.rowData.arrayFilter.push({\n                        display: dataPoint.label,\n                        filter: dataPoint.value,\n                        shown: +dataPoint.count,\n                        sort: dataPoint.label,\n                        total: +dataPoint.total,\n                        type: dataPoint.label\n                    });\n                    this.s.rowData.binsShown[dataPoint.value] = +dataPoint.count;\n                    this.s.rowData.bins[dataPoint.value] = +dataPoint.total;\n                }\n            }\n            var binLength = Object.keys(this.s.rowData.bins).length;\n            var uniqueRatio = this._uniqueRatio(binLength, this.s.tableLength);\n            // Don't show the pane if there isnt enough variance in the data, or there is only 1 entry for that pane\n            if (!this.s.colOpts.show &&\n                this.s.displayed === false &&\n                ((this.s.colOpts.show === undefined && this.s.colOpts.threshold === null ?\n                    uniqueRatio > this.c.threshold :\n                    uniqueRatio > this.s.colOpts.threshold) ||\n                    this.s.colOpts.show !== true && binLength <= 1)) {\n                this.dom.container.addClass(this.classes.hidden);\n                this.s.displayed = false;\n                return;\n            }\n            // Store the original data\n            this.s.rowData.arrayOriginal = this.s.rowData.arrayFilter;\n            this.s.rowData.binsOriginal = this.s.rowData.bins;\n            // Flag this pane as being displayed\n            this.s.displayed = true;\n            // If the pane exists\n            if (this.s.dtPane) {\n                // Not the selections that have been made and remove all of the rows\n                var selected = this.s.serverSelect;\n                this.s.dtPane.rows().remove();\n                // Add the rows that are to be shown into the pane\n                for (var _b = 0, _c = this.s.rowData.arrayFilter; _b < _c.length; _b++) {\n                    var data = _c[_b];\n                    if (this._shouldAddRow(data)) {\n                        var row = this.addRow(data.display, data.filter, data.sort, data.type);\n                        // Select the row if it was selected before\n                        for (var i = 0; i < selected.length; i++) {\n                            var selection = selected[i];\n                            if (selection.filter === data.filter) {\n                                // This flag stops another request being made to the server\n                                this.s.serverSelecting = true;\n                                row.select();\n                                this.s.serverSelecting = false;\n                                // Remove the selection from the to select list and add it to the selected list\n                                selected.splice(i, 1);\n                                this.s.selections.push(data.filter);\n                                break;\n                            }\n                        }\n                    }\n                }\n                // Remake any selections that are no longer present\n                for (var _d = 0, selected_1 = selected; _d < selected_1.length; _d++) {\n                    var selection = selected_1[_d];\n                    for (var _e = 0, _f = this.s.rowData.arrayOriginal; _e < _f.length; _e++) {\n                        var data = _f[_e];\n                        if (data.filter === selection.filter) {\n                            var row = this.addRow(data.display, data.filter, data.sort, data.type);\n                            this.s.serverSelecting = true;\n                            row.select();\n                            this.s.serverSelecting = false;\n                            this.s.selections.push(data.filter);\n                        }\n                    }\n                }\n                // Store the selected rows\n                this.s.serverSelect = this.s.dtPane.rows({ selected: true }).data().toArray();\n                // Update the pane\n                this.s.dtPane.draw();\n            }\n        };\n        /**\n         * This method updates the rows and their data within the SearchPanes\n         *\n         * SearchPaneCascade overrides this method\n         */\n        SearchPaneST.prototype.updateRows = function () {\n            if (!this.s.dt.page.info().serverSide) {\n                // Get the latest count values from the table\n                this.s.rowData.binsShown = {};\n                for (var _i = 0, _a = this.s.dt.rows({ search: 'applied' }).indexes().toArray(); _i < _a.length; _i++) {\n                    var index = _a[_i];\n                    this._updateShown(index, this.s.dt.settings()[0], this.s.rowData.binsShown);\n                }\n            }\n            // Update the rows data to show the current counts\n            for (var _b = 0, _c = this.s.dtPane.rows().data().toArray(); _b < _c.length; _b++) {\n                var row = _c[_b];\n                row.shown = typeof this.s.rowData.binsShown[row.filter] === 'number' ?\n                    this.s.rowData.binsShown[row.filter] :\n                    0;\n                this.s.dtPane.row(row.index).data(row);\n            }\n            // Show updates in the pane\n            this.s.dtPane.draw();\n            this.s.dtPane.table().node().parentNode.scrollTop = this.s.scrollTop;\n        };\n        /**\n         * Remove functionality from makeSelection - needs to be more advanced when tracking selections\n         */\n        SearchPaneST.prototype._makeSelection = function () {\n            return;\n        };\n        /**\n         * Blank method to remove reloading of selected rows - needs to be more advanced when tracking selections\n         */\n        SearchPaneST.prototype._reloadSelect = function () {\n            return;\n        };\n        /**\n         * Decides if a row should be added when being added from the server\n         *\n         * Overridden by SearchPaneCascade\n         *\n         * @param data the row data\n         * @returns boolean indicating if the row should be added or not\n         */\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        SearchPaneST.prototype._shouldAddRow = function (data) {\n            return true;\n        };\n        /**\n         * Updates the server selection list where appropriate\n         */\n        SearchPaneST.prototype._updateSelection = function () {\n            if (this.s.dt.page.info().serverSide && !this.s.updating && !this.s.serverSelecting) {\n                this.s.serverSelect = this.s.dtPane.rows({ selected: true }).data().toArray();\n            }\n        };\n        /**\n         * Used when binning the data for a column\n         *\n         * @param rowIdx The current row that is to be added to the bins\n         * @param settings The datatables settings object\n         * @param bins The bins object that is to be incremented\n         */\n        SearchPaneST.prototype._updateShown = function (rowIdx, settings, bins) {\n            if (bins === void 0) { bins = this.s.rowData.binsShown; }\n            var orth = typeof this.s.colOpts.orthogonal === 'string'\n                ? this.s.colOpts.orthogonal\n                : this.s.colOpts.orthogonal.search;\n            var filter = settings.oApi._fnGetCellData(settings, rowIdx, this.s.index, orth);\n            var add = function (f) {\n                if (!bins[f]) {\n                    bins[f] = 1;\n                }\n                else {\n                    bins[f]++;\n                }\n            };\n            if (Array.isArray(filter)) {\n                for (var _i = 0, filter_1 = filter; _i < filter_1.length; _i++) {\n                    var f = filter_1[_i];\n                    add(f);\n                }\n            }\n            else {\n                add(filter);\n            }\n        };\n        return SearchPaneST;\n    }(SearchPane));\n\n    var __extends$3 = (window && window.__extends) || (function () {\n        var extendStatics = function (d, b) {\n            extendStatics = Object.setPrototypeOf ||\n                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n            return extendStatics(d, b);\n        };\n        return function (d, b) {\n            extendStatics(d, b);\n            function __() { this.constructor = d; }\n            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n        };\n    })();\n    var $$4;\n    function setJQuery$3(jq) {\n        $$4 = jq;\n    }\n    var SearchPaneViewTotal = /** @class */ (function (_super) {\n        __extends$3(SearchPaneViewTotal, _super);\n        function SearchPaneViewTotal(paneSettings, opts, index, panesContainer, panes) {\n            var _this = this;\n            var override = {\n                i18n: {\n                    countFiltered: '{shown} ({total})'\n                }\n            };\n            _this = _super.call(this, paneSettings, $$4.extend(override, opts), index, panesContainer, panes) || this;\n            return _this;\n        }\n        /**\n         * Gets the message that is to be used to indicate the count for each SearchPane row\n         *\n         * This method overrides _getMessage() in SearchPane and is overridden by SearchPaneCascadeViewTotal\n         *\n         * @param row The row object that is being processed\n         * @returns string - the message that is to be shown for the count of each entry\n         */\n        SearchPaneViewTotal.prototype._getMessage = function (row) {\n            var countMessage = this.s.dt.i18n('searchPanes.count', this.c.i18n.count);\n            var filteredMessage = this.s.dt.i18n('searchPanes.countFiltered', this.c.i18n.countFiltered);\n            return (this.s.filteringActive ? filteredMessage : countMessage)\n                .replace(/{total}/g, row.total)\n                .replace(/{shown}/g, row.shown);\n        };\n        /**\n         * Overrides the blank method in SearchPane to return the number of times a given value is currently being displayed\n         *\n         * @param filter The filter value\n         * @returns number - The number of times the value is shown\n         */\n        SearchPaneViewTotal.prototype._getShown = function (filter) {\n            return this.s.rowData.binsShown && this.s.rowData.binsShown[filter] ?\n                this.s.rowData.binsShown[filter] :\n                0;\n        };\n        return SearchPaneViewTotal;\n    }(SearchPaneST));\n\n    var __extends$2 = (window && window.__extends) || (function () {\n        var extendStatics = function (d, b) {\n            extendStatics = Object.setPrototypeOf ||\n                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n            return extendStatics(d, b);\n        };\n        return function (d, b) {\n            extendStatics(d, b);\n            function __() { this.constructor = d; }\n            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n        };\n    })();\n    var $$3;\n    function setJQuery$2(jq) {\n        $$3 = jq;\n    }\n    var SearchPaneCascade = /** @class */ (function (_super) {\n        __extends$2(SearchPaneCascade, _super);\n        function SearchPaneCascade(paneSettings, opts, index, panesContainer, panes) {\n            var _this = this;\n            var override = {\n                i18n: {\n                    count: '{shown}'\n                }\n            };\n            _this = _super.call(this, paneSettings, $$3.extend(override, opts), index, panesContainer, panes) || this;\n            return _this;\n        }\n        /**\n         * This method updates the rows and their data within the SearchPanes\n         *\n         * This overrides the method in SearchPane\n         */\n        SearchPaneCascade.prototype.updateRows = function () {\n            // Note the currently selected values in the pane and remove all of the rows\n            var selected = this.s.dtPane.rows({ selected: true }).data().toArray();\n            if (this.s.colOpts.options ||\n                this.s.customPaneSettings && this.s.customPaneSettings.options) {\n                // If there are custom options set or it is a custom pane then get them\n                this._getComparisonRows();\n                var rows = this.s.dtPane.rows().toArray()[0];\n                for (var i = 0; i < rows.length; i++) {\n                    var row = this.s.dtPane.row(rows[i]);\n                    var rowData = row.data();\n                    if (rowData === undefined) {\n                        continue;\n                    }\n                    if (rowData.shown === 0) {\n                        row.remove();\n                        rows = this.s.dtPane.rows().toArray()[0];\n                        i--;\n                        continue;\n                    }\n                    for (var _i = 0, selected_1 = selected; _i < selected_1.length; _i++) {\n                        var selection = selected_1[_i];\n                        if (rowData.filter === selection.filter) {\n                            row.select();\n                            selected.splice(i, 1);\n                            this.s.selections.push(rowData.filter);\n                            break;\n                        }\n                    }\n                }\n            }\n            else {\n                if (!this.s.dt.page.info().serverSide) {\n                    // Get the latest count values from the table\n                    this._activePopulatePane();\n                    this.s.rowData.binsShown = {};\n                    for (var _a = 0, _b = this.s.dt.rows({ search: 'applied' }).indexes().toArray(); _a < _b.length; _a++) {\n                        var index = _b[_a];\n                        this._updateShown(index, this.s.dt.settings()[0], this.s.rowData.binsShown);\n                    }\n                }\n                this.s.dtPane.rows().remove();\n                // Go over all of the rows that could be displayed\n                for (var _c = 0, _d = this.s.rowData.arrayFilter; _c < _d.length; _c++) {\n                    var data = _d[_c];\n                    // Cascade - If there are no rows present in the table don't show the option\n                    if (data.shown === 0) {\n                        continue;\n                    }\n                    // Add the row to the pane\n                    var row = this.addRow(data.display, data.filter, data.sort, data.type, undefined);\n                    // Check if this row was selected\n                    for (var i = 0; i < selected.length; i++) {\n                        var selection = selected[i];\n                        if (selection.filter === data.filter) {\n                            row.select();\n                            // Remove the row from the to find list and then add it to the selections list\n                            selected.splice(i, 1);\n                            this.s.selections.push(data.filter);\n                            break;\n                        }\n                    }\n                }\n                // Add all of the rows that were previously selected but aren't any more\n                for (var _e = 0, selected_2 = selected; _e < selected_2.length; _e++) {\n                    var selection = selected_2[_e];\n                    for (var _f = 0, _g = this.s.rowData.arrayOriginal; _f < _g.length; _f++) {\n                        var data = _g[_f];\n                        if (data.filter === selection.filter) {\n                            var row = this.addRow(data.display, data.filter, data.sort, data.type, undefined);\n                            row.select();\n                            this.s.selections.push(data.filter);\n                        }\n                    }\n                }\n            }\n            // Show updates in the pane\n            this.s.dtPane.draw();\n            this.s.dtPane.table().node().parentNode.scrollTop = this.s.scrollTop;\n            // If client side updated the tables results\n            if (!this.s.dt.page.info().serverSide) {\n                this.s.dt.draw(false);\n            }\n        };\n        /**\n         * Fill the array with the values that are currently being displayed in the table\n         */\n        SearchPaneCascade.prototype._activePopulatePane = function () {\n            this.s.rowData.arrayFilter = [];\n            this.s.rowData.bins = {};\n            var settings = this.s.dt.settings()[0];\n            if (!this.s.dt.page.info().serverSide) {\n                for (var _i = 0, _a = this.s.dt.rows({ search: 'applied' }).indexes().toArray(); _i < _a.length; _i++) {\n                    var index = _a[_i];\n                    this._populatePaneArray(index, this.s.rowData.arrayFilter, settings);\n                }\n            }\n        };\n        SearchPaneCascade.prototype._getComparisonRows = function () {\n            // Find the appropriate options depending on whether this is a pane for a specific column or a custom pane\n            var options = this.s.colOpts.options\n                ? this.s.colOpts.options\n                : this.s.customPaneSettings && this.s.customPaneSettings.options\n                    ? this.s.customPaneSettings.options\n                    : undefined;\n            if (options === undefined) {\n                return;\n            }\n            var allRows = this.s.dt.rows();\n            var shownRows = this.s.dt.rows({ search: 'applied' });\n            var tableValsTotal = allRows.data().toArray();\n            var tableValsShown = shownRows.data().toArray();\n            var rows = [];\n            // Clear all of the other rows from the pane, only custom options are to be displayed when they are defined\n            this.s.dtPane.clear();\n            this.s.indexes = [];\n            for (var _i = 0, options_1 = options; _i < options_1.length; _i++) {\n                var comp = options_1[_i];\n                // Initialise the object which is to be placed in the row\n                var insert = comp.label !== '' ?\n                    comp.label :\n                    this.emptyMessage();\n                var comparisonObj = {\n                    className: comp.className,\n                    display: insert,\n                    filter: typeof comp.value === 'function' ? comp.value : [],\n                    shown: 0,\n                    sort: insert,\n                    total: 0,\n                    type: insert\n                };\n                // If a custom function is in place\n                if (typeof comp.value === 'function') {\n                    // Count the number of times the function evaluates to true for the original data in the Table\n                    for (var i = 0; i < tableValsTotal.length; i++) {\n                        if (comp.value.call(this.s.dt, tableValsTotal[i], allRows[0][i])) {\n                            comparisonObj.total++;\n                        }\n                    }\n                    for (var i = 0; i < tableValsShown.length; i++) {\n                        if (comp.value.call(this.s.dt, tableValsShown[i], shownRows[0][i])) {\n                            comparisonObj.shown++;\n                        }\n                    }\n                    // Update the comparisonObj\n                    if (typeof comparisonObj.filter !== 'function') {\n                        comparisonObj.filter.push(comp.filter);\n                    }\n                }\n                rows.push(this.addRow(comparisonObj.display, comparisonObj.filter, comparisonObj.sort, comparisonObj.type, comparisonObj.className, comparisonObj.total, comparisonObj.shown));\n            }\n            return rows;\n        };\n        /**\n         * Gets the message that is to be used to indicate the count for each SearchPane row\n         *\n         * This method overrides _getMessage() in SearchPane and is overridden by SearchPaneCascadeViewTotal\n         *\n         * @param row The row object that is being processed\n         * @returns string - the message that is to be shown for the count of each entry\n         */\n        SearchPaneCascade.prototype._getMessage = function (row) {\n            return this.s.dt.i18n('searchPanes.count', this.c.i18n.count)\n                .replace(/{total}/g, row.total)\n                .replace(/{shown}/g, row.shown);\n        };\n        /**\n         * Overrides the blank method in SearchPane to return the number of times a given value is currently being displayed\n         *\n         * @param filter The filter value\n         * @returns number - The number of times the value is shown\n         */\n        SearchPaneCascade.prototype._getShown = function (filter) {\n            return this.s.rowData.binsShown && this.s.rowData.binsShown[filter] ?\n                this.s.rowData.binsShown[filter] :\n                0;\n        };\n        /**\n         * Decides if a row should be added when being added from the server\n         *\n         * Overrides method in by SearchPaneST\n         *\n         * @param data the row data\n         * @returns boolean indicating if the row should be added or not\n         */\n        SearchPaneCascade.prototype._shouldAddRow = function (data) {\n            return data.shown > 0;\n        };\n        return SearchPaneCascade;\n    }(SearchPaneST));\n\n    var __extends$1 = (window && window.__extends) || (function () {\n        var extendStatics = function (d, b) {\n            extendStatics = Object.setPrototypeOf ||\n                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n            return extendStatics(d, b);\n        };\n        return function (d, b) {\n            extendStatics(d, b);\n            function __() { this.constructor = d; }\n            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n        };\n    })();\n    var $$2;\n    function setJQuery$1(jq) {\n        $$2 = jq;\n    }\n    var SearchPaneCascadeViewTotal = /** @class */ (function (_super) {\n        __extends$1(SearchPaneCascadeViewTotal, _super);\n        function SearchPaneCascadeViewTotal(paneSettings, opts, index, panesContainer, panes) {\n            var _this = this;\n            var override = {\n                i18n: {\n                    count: '{total}',\n                    countFiltered: '{shown} ({total})'\n                }\n            };\n            _this = _super.call(this, paneSettings, $$2.extend(override, opts), index, panesContainer, panes) || this;\n            return _this;\n        }\n        /**\n         * Fill the array with the values that are currently being displayed in the table\n         *\n         * This method overrides _activePopulatePane() in SearchPaneCascade\n         */\n        SearchPaneCascadeViewTotal.prototype._activePopulatePane = function () {\n            this.s.rowData.arrayFilter = [];\n            this.s.rowData.binsShown = {};\n            var settings = this.s.dt.settings()[0];\n            if (!this.s.dt.page.info().serverSide) {\n                for (var _i = 0, _a = this.s.dt.rows({ search: 'applied' }).indexes().toArray(); _i < _a.length; _i++) {\n                    var index = _a[_i];\n                    this._populatePaneArray(index, this.s.rowData.arrayFilter, settings, this.s.rowData.binsShown);\n                }\n            }\n        };\n        /**\n         * Gets the message that is to be used to indicate the count for each SearchPane row\n         *\n         * This method overrides _getMessage() in SearchPaneCascade\n         *\n         * @param row The row object that is being processed\n         * @returns string - the message that is to be shown for the count of each entry\n         */\n        SearchPaneCascadeViewTotal.prototype._getMessage = function (row) {\n            var countMessage = this.s.dt.i18n('searchPanes.count', this.c.i18n.count);\n            var filteredMessage = this.s.dt.i18n('searchPanes.countFiltered', this.c.i18n.countFiltered);\n            return (this.s.filteringActive ? filteredMessage : countMessage)\n                .replace(/{total}/g, row.total)\n                .replace(/{shown}/g, row.shown);\n        };\n        return SearchPaneCascadeViewTotal;\n    }(SearchPaneCascade));\n\n    var $$1;\n    var dataTable$1;\n    function setJQuery(jq) {\n        $$1 = jq;\n        dataTable$1 = jq.fn.dataTable;\n    }\n    var SearchPanes = /** @class */ (function () {\n        function SearchPanes(paneSettings, opts, fromPreInit, paneClass) {\n            var _this = this;\n            if (fromPreInit === void 0) { fromPreInit = false; }\n            if (paneClass === void 0) { paneClass = SearchPane; }\n            // Check that the required version of DataTables is included\n            if (!dataTable$1 || !dataTable$1.versionCheck || !dataTable$1.versionCheck('1.10.0')) {\n                throw new Error('SearchPane requires DataTables 1.10 or newer');\n            }\n            // Check that Select is included\n            // eslint-disable-next-line no-extra-parens\n            if (!dataTable$1.select) {\n                throw new Error('SearchPane requires Select');\n            }\n            var table = new dataTable$1.Api(paneSettings);\n            this.classes = $$1.extend(true, {}, SearchPanes.classes);\n            // Get options from user\n            this.c = $$1.extend(true, {}, SearchPanes.defaults, opts);\n            // Add extra elements to DOM object including clear\n            this.dom = {\n                clearAll: $$1('<button type=\"button\"/>')\n                    .addClass(this.classes.clearAll)\n                    .html(table.i18n('searchPanes.clearMessage', this.c.i18n.clearMessage)),\n                collapseAll: $$1('<button type=\"button\"/>')\n                    .addClass(this.classes.collapseAll)\n                    .html(table.i18n('searchPanes.collapseMessage', this.c.i18n.collapseMessage)),\n                container: $$1('<div/>').addClass(this.classes.panes).html(table.i18n('searchPanes.loadMessage', this.c.i18n.loadMessage)),\n                emptyMessage: $$1('<div/>').addClass(this.classes.emptyMessage),\n                panes: $$1('<div/>').addClass(this.classes.container),\n                showAll: $$1('<button type=\"button\"/>')\n                    .addClass(this.classes.showAll)\n                    .addClass(this.classes.disabledButton)\n                    .attr('disabled', 'true')\n                    .html(table.i18n('searchPanes.showMessage', this.c.i18n.showMessage)),\n                title: $$1('<div/>').addClass(this.classes.title),\n                titleRow: $$1('<div/>').addClass(this.classes.titleRow)\n            };\n            this.s = {\n                colOpts: [],\n                dt: table,\n                filterCount: 0,\n                minPaneWidth: 260.0,\n                page: 0,\n                paging: false,\n                pagingST: false,\n                paneClass: paneClass,\n                panes: [],\n                selectionList: [],\n                serverData: {},\n                stateRead: false,\n                updating: false\n            };\n            // Do not reinitialise if already initialised on table\n            if (table.settings()[0]._searchPanes) {\n                return;\n            }\n            this._getState();\n            if (this.s.dt.page.info().serverSide) {\n                var hostSettings = this.s.dt.settings()[0];\n                // Listener to get the data into the server request before it is made\n                this.s.dt.on('preXhr.dtsps', function (e, settings, data) {\n                    if (hostSettings !== settings) {\n                        return;\n                    }\n                    if (data.searchPanes === undefined) {\n                        data.searchPanes = {};\n                    }\n                    if (data.searchPanes_null === undefined) {\n                        data.searchPanes_null = {};\n                    }\n                    var src;\n                    for (var _i = 0, _a = _this.s.selectionList; _i < _a.length; _i++) {\n                        var selection = _a[_i];\n                        src = _this.s.dt.column(selection.column).dataSrc();\n                        if (data.searchPanes[src] === undefined) {\n                            data.searchPanes[src] = {};\n                        }\n                        if (data.searchPanes_null[src] === undefined) {\n                            data.searchPanes_null[src] = {};\n                        }\n                        for (var i = 0; i < selection.rows.length; i++) {\n                            data.searchPanes[src][i] = selection.rows[i];\n                            if (data.searchPanes[src][i] === null) {\n                                data.searchPanes_null[src][i] = true;\n                            }\n                        }\n                    }\n                    if (_this.s.selectionList.length > 0) {\n                        data.searchPanesLast = src;\n                    }\n                    // Config options that will change how the querying is done\n                    data.searchPanes_options = {\n                        cascade: _this.c.cascadePanes,\n                        viewCount: _this.c.viewCount,\n                        viewTotal: _this.c.viewTotal\n                    };\n                });\n            }\n            this._setXHR();\n            table.settings()[0]._searchPanes = this;\n            if (this.s.dt.settings()[0]._bInitComplete || fromPreInit) {\n                this._paneDeclare(table, paneSettings, opts);\n            }\n            else {\n                table.one('preInit.dtsps', function () {\n                    _this._paneDeclare(table, paneSettings, opts);\n                });\n            }\n            return this;\n        }\n        /**\n         * Clear the selections of all of the panes\n         */\n        SearchPanes.prototype.clearSelections = function () {\n            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {\n                var pane = _a[_i];\n                if (pane.s.dtPane) {\n                    pane.s.scrollTop = pane.s.dtPane.table().node().parentNode.scrollTop;\n                }\n            }\n            // Load in all of the searchBoxes in the documents\n            var searches = this.dom.container.find('.' + this.classes.search.replace(/\\s+/g, '.'));\n            // For each searchBox set the input text to be empty and then trigger\n            // an input on them so that they no longer filter the panes\n            searches.each(function () {\n                $$1(this).val('').trigger('input');\n            });\n            // Clear the selectionList\n            this.s.selectionList = [];\n            var returnArray = [];\n            for (var _b = 0, _c = this.s.panes; _b < _c.length; _b++) {\n                var pane = _c[_b];\n                if (pane.s.dtPane) {\n                    returnArray.push(pane.clearPane());\n                }\n            }\n            return returnArray;\n        };\n        /**\n         * returns the container node for the searchPanes\n         */\n        SearchPanes.prototype.getNode = function () {\n            return this.dom.container;\n        };\n        /**\n         * rebuilds all of the panes\n         */\n        SearchPanes.prototype.rebuild = function (targetIdx, maintainSelection) {\n            if (targetIdx === void 0) { targetIdx = false; }\n            if (maintainSelection === void 0) { maintainSelection = false; }\n            this.dom.emptyMessage.detach();\n            // As a rebuild from scratch is required, empty the searchpanes container.\n            if (targetIdx === false) {\n                this.dom.panes.empty();\n            }\n            // Rebuild each pane individually, if a specific pane has been selected then only rebuild that one\n            var returnArray = [];\n            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {\n                var pane = _a[_i];\n                if (targetIdx === false || pane.s.index === targetIdx) {\n                    pane.clearData();\n                    pane.rebuildPane(this.s.dt.page.info().serverSide ?\n                        this.s.serverData :\n                        undefined, maintainSelection);\n                    this.dom.panes.append(pane.dom.container);\n                    returnArray.push(pane);\n                }\n            }\n            this._updateSelection();\n            // Attach panes, clear buttons, and title bar to the document\n            this._updateFilterCount();\n            this._attachPaneContainer();\n            this._initSelectionListeners(false);\n            // If the selections are to be maintained, then it is safe to assume that paging is also to be maintained\n            // Otherwise, the paging should be reset\n            this.s.dt.draw(!maintainSelection);\n            // Resize the panes incase there has been a change\n            this.resizePanes();\n            // If a single pane has been rebuilt then return only that pane\n            return returnArray.length === 1 ? returnArray[0] : returnArray;\n        };\n        /**\n         * Resizes all of the panes\n         */\n        SearchPanes.prototype.resizePanes = function () {\n            if (this.c.layout === 'auto') {\n                var contWidth = $$1(this.s.dt.searchPanes.container()).width();\n                var target = Math.floor(contWidth / this.s.minPaneWidth); // The neatest number of panes per row\n                var highest_1 = 1;\n                var highestmod_1 = 0;\n                // Get the indexes of all of the displayed panes\n                var dispIndex = [];\n                for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {\n                    var pane = _a[_i];\n                    if (pane.s.displayed) {\n                        dispIndex.push(pane.s.index);\n                    }\n                }\n                var displayCount = dispIndex.length;\n                // If the neatest number is the number we have then use this.\n                if (target === displayCount) {\n                    highest_1 = target;\n                }\n                else {\n                    // Go from the target down and find the value with the most panes left over, this will be the best fit\n                    for (var ppr = target; ppr > 1; ppr--) {\n                        var rem = displayCount % ppr;\n                        if (rem === 0) {\n                            highest_1 = ppr;\n                            highestmod_1 = 0;\n                            break;\n                        }\n                        // If there are more left over at this amount of panes per row (ppr)\n                        // then it fits better so new values\n                        else if (rem > highestmod_1) {\n                            highest_1 = ppr;\n                            highestmod_1 = rem;\n                        }\n                    }\n                }\n                // If there is a perfect fit then none are to be wider\n                var widerIndexes_1 = highestmod_1 !== 0 ? dispIndex.slice(dispIndex.length - highestmod_1, dispIndex.length) : [];\n                this.s.panes.forEach(function (pane) {\n                    // Resize the pane with the new layout\n                    if (pane.s.displayed) {\n                        pane.resize('columns-' + (!widerIndexes_1.includes(pane.s.index) ? highest_1 : highestmod_1));\n                    }\n                });\n            }\n            else {\n                for (var _b = 0, _c = this.s.panes; _b < _c.length; _b++) {\n                    var pane = _c[_b];\n                    pane.adjustTopRow();\n                }\n            }\n            return this;\n        };\n        /**\n         * Holder method that is userd in SearchPanesST to set listeners that have an effect on other panes\n         *\n         * @param isPreselect boolean to indicate if the preselect array is to override the current selection list.\n         */\n        SearchPanes.prototype._initSelectionListeners = function (isPreselect) {\n            return;\n        };\n        /**\n         * Blank method that is overridden in SearchPanesST to retrieve the totals from the server data\n         */\n        SearchPanes.prototype._serverTotals = function () {\n            return;\n        };\n        /**\n         * Set's the xhr listener so that SP can extact appropriate data from the response\n         */\n        SearchPanes.prototype._setXHR = function () {\n            var _this = this;\n            var hostSettings = this.s.dt.settings()[0];\n            var run = function (json) {\n                if (json && json.searchPanes && json.searchPanes.options) {\n                    _this.s.serverData = json;\n                    _this.s.serverData.tableLength = json.recordsTotal;\n                    _this._serverTotals();\n                }\n            };\n            // We are using the xhr event to rebuild the panes if required due to viewTotal being enabled\n            // If viewTotal is not enabled then we simply update the data from the server\n            this.s.dt.on('xhr.dtsps', function (e, settings, json) {\n                if (hostSettings === settings) {\n                    run(json);\n                }\n            });\n            // Account for the initial JSON fetch having already completed\n            run(this.s.dt.ajax.json());\n        };\n        /**\n         * Set's the function that is to be performed when a state is loaded\n         *\n         * Overridden by the method in SearchPanesST\n         */\n        SearchPanes.prototype._stateLoadListener = function () {\n            var _this = this;\n            var hostSettings = this.s.dt.settings()[0];\n            this.s.dt.on('stateLoadParams.dtsps', function (e, settings, data) {\n                if (data.searchPanes === undefined || settings !== hostSettings) {\n                    return;\n                }\n                _this.clearSelections();\n                // Set the selection list for the panes so that the correct\n                // rows can be reselected and in the right order\n                _this.s.selectionList =\n                    data.searchPanes.selectionList ?\n                        data.searchPanes.selectionList :\n                        [];\n                // Find the panes that match from the state and the actual instance\n                if (data.searchPanes.panes) {\n                    for (var _i = 0, _a = data.searchPanes.panes; _i < _a.length; _i++) {\n                        var loadedPane = _a[_i];\n                        for (var _b = 0, _c = _this.s.panes; _b < _c.length; _b++) {\n                            var pane = _c[_b];\n                            if (loadedPane.id === pane.s.index && pane.s.dtPane) {\n                                // Set the value of the searchbox\n                                pane.dom.searchBox.val(loadedPane.searchTerm);\n                                // Set the value of the order\n                                pane.s.dtPane.order(loadedPane.order);\n                            }\n                        }\n                    }\n                }\n                _this._makeSelections(_this.s.selectionList);\n            });\n        };\n        /**\n         * Updates the selectionList when cascade is not in place\n         *\n         * Overridden in SearchPanesST\n         */\n        SearchPanes.prototype._updateSelection = function () {\n            this.s.selectionList = [];\n            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {\n                var pane = _a[_i];\n                if (pane.s.dtPane) {\n                    var rows = pane.s.dtPane.rows({ selected: true }).data().toArray().map(function (el) { return el.filter; });\n                    if (rows.length) {\n                        this.s.selectionList.push({\n                            column: pane.s.index,\n                            rows: rows\n                        });\n                    }\n                }\n            }\n        };\n        /**\n         * Attach the panes, buttons and title to the document\n         */\n        SearchPanes.prototype._attach = function () {\n            var _this = this;\n            this.dom.titleRow\n                .removeClass(this.classes.hide)\n                .detach()\n                .append(this.dom.title);\n            // If the clear button is permitted attach it\n            if (this.c.clear) {\n                this.dom.clearAll\n                    .appendTo(this.dom.titleRow)\n                    .on('click.dtsps', function () { return _this.clearSelections(); });\n            }\n            if (this.c.collapse) {\n                this.dom.showAll.appendTo(this.dom.titleRow);\n                this.dom.collapseAll.appendTo(this.dom.titleRow);\n                this._setCollapseListener();\n            }\n            // Attach the container for each individual pane to the overall container\n            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {\n                var pane = _a[_i];\n                this.dom.panes.append(pane.dom.container);\n            }\n            // Attach everything to the document\n            this.dom.container\n                .text('')\n                .removeClass(this.classes.hide)\n                .append(this.dom.titleRow)\n                .append(this.dom.panes);\n            // WORKAROUND\n            this.s.panes.forEach(function (pane) { return pane.setListeners(); });\n            if ($$1('div.' + this.classes.container).length === 0) {\n                this.dom.container.prependTo(this.s.dt);\n            }\n        };\n        /**\n         * If there are no panes to display then this method is called to either\n         * display a message in their place or hide them completely.\n         */\n        SearchPanes.prototype._attachMessage = function () {\n            // Create a message to display on the screen\n            var message;\n            try {\n                message = this.s.dt.i18n('searchPanes.emptyPanes', this.c.i18n.emptyPanes);\n            }\n            catch (error) {\n                message = null;\n            }\n            // If the message is an empty string then searchPanes.emptyPanes is undefined,\n            // therefore the pane container should be removed from the display\n            if (message === null) {\n                this.dom.container.addClass(this.classes.hide);\n                this.dom.titleRow.removeClass(this.classes.hide);\n                return;\n            }\n            // Otherwise display the message\n            this.dom.container.removeClass(this.classes.hide);\n            this.dom.titleRow.addClass(this.classes.hide);\n            this.dom.emptyMessage.html(message).appendTo(this.dom.container);\n        };\n        /**\n         * Attaches the panes to the document and displays a message or hides if there are none\n         */\n        SearchPanes.prototype._attachPaneContainer = function () {\n            // If a pane is to be displayed then attach the normal pane output\n            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {\n                var pane = _a[_i];\n                if (pane.s.displayed === true) {\n                    this._attach();\n                    return;\n                }\n            }\n            // Otherwise attach the custom message or remove the container from the display\n            this._attachMessage();\n        };\n        /**\n         * Checks which panes are collapsed and then performs relevant actions to the collapse/show all buttons\n         */\n        SearchPanes.prototype._checkCollapse = function () {\n            var disableClose = true;\n            var disableShow = true;\n            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {\n                var pane = _a[_i];\n                if (pane.s.displayed) {\n                    // If the pane is not collapsed\n                    if (!pane.dom.collapseButton.hasClass(pane.classes.rotated)) {\n                        // Enable the collapse all button\n                        this.dom.collapseAll.removeClass(this.classes.disabledButton).removeAttr('disabled');\n                        disableClose = false;\n                    }\n                    else {\n                        // Otherwise enable the show all button\n                        this.dom.showAll.removeClass(this.classes.disabledButton).removeAttr('disabled');\n                        disableShow = false;\n                    }\n                }\n            }\n            // If this flag is still true, no panes are open so the close button should be disabled\n            if (disableClose) {\n                this.dom.collapseAll.addClass(this.classes.disabledButton).attr('disabled', 'true');\n            }\n            // If this flag is still true, no panes are closed so the show button should be disabled\n            if (disableShow) {\n                this.dom.showAll.addClass(this.classes.disabledButton).attr('disabled', 'true');\n            }\n        };\n        /**\n         * Attaches the message to the document but does not add any panes\n         */\n        SearchPanes.prototype._checkMessage = function () {\n            // If a pane is to be displayed then attach the normal pane output\n            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {\n                var pane = _a[_i];\n                if (pane.s.displayed === true) {\n                    // Ensure that the empty message is removed if a pane is displayed\n                    this.dom.emptyMessage.detach();\n                    this.dom.titleRow.removeClass(this.classes.hide);\n                    return;\n                }\n            }\n            // Otherwise attach the custom message or remove the container from the display\n            this._attachMessage();\n        };\n        /**\n         * Collapses all of the panes\n         */\n        SearchPanes.prototype._collapseAll = function () {\n            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {\n                var pane = _a[_i];\n                pane.collapse();\n            }\n        };\n        /**\n         * Finds a pane based upon the name of that pane\n         *\n         * @param name string representing the name of the pane\n         * @returns SearchPane The pane which has that name\n         */\n        SearchPanes.prototype._findPane = function (name) {\n            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {\n                var pane = _a[_i];\n                if (name === pane.s.name) {\n                    return pane;\n                }\n            }\n        };\n        /**\n         * Gets the selection list from the previous state and stores it in the selectionList Property\n         */\n        SearchPanes.prototype._getState = function () {\n            var loadedFilter = this.s.dt.state.loaded();\n            if (loadedFilter && loadedFilter.searchPanes && loadedFilter.searchPanes.selectionList) {\n                this.s.selectionList = loadedFilter.searchPanes.selectionList;\n            }\n        };\n        SearchPanes.prototype._makeSelections = function (selectList) {\n            for (var _i = 0, selectList_1 = selectList; _i < selectList_1.length; _i++) {\n                var selection = selectList_1[_i];\n                var pane = void 0;\n                for (var _a = 0, _b = this.s.panes; _a < _b.length; _a++) {\n                    var p = _b[_a];\n                    if (p.s.index === selection.column) {\n                        pane = p;\n                        break;\n                    }\n                }\n                if (pane && pane.s.dtPane) {\n                    for (var j = 0; j < pane.s.dtPane.rows().data().toArray().length; j++) {\n                        if (selection.rows.includes(typeof pane.s.dtPane.row(j).data().filter === 'function' ?\n                            pane.s.dtPane.cell(j, 0).data() :\n                            pane.s.dtPane.row(j).data().filter)) {\n                            pane.s.dtPane.row(j).select();\n                        }\n                    }\n                    pane.updateTable();\n                }\n            }\n        };\n        /**\n         * Declares the instances of individual searchpanes dependant on the number of columns.\n         * It is necessary to run this once preInit has completed otherwise no panes will be\n         * created as the column count will be 0.\n         *\n         * @param table the DataTable api for the parent table\n         * @param paneSettings the settings passed into the constructor\n         * @param opts the options passed into the constructor\n         */\n        SearchPanes.prototype._paneDeclare = function (table, paneSettings, opts) {\n            var _this = this;\n            // Create Panes\n            table\n                .columns(this.c.columns.length > 0 ? this.c.columns : undefined)\n                .eq(0)\n                .each(function (idx) {\n                _this.s.panes.push(new _this.s.paneClass(paneSettings, opts, idx, _this.dom.panes));\n            });\n            // If there is any extra custom panes defined then create panes for them too\n            var colCount = table.columns().eq(0).toArray().length;\n            for (var i = 0; i < this.c.panes.length; i++) {\n                var id = colCount + i;\n                this.s.panes.push(new this.s.paneClass(paneSettings, opts, id, this.dom.panes, this.c.panes[i]));\n            }\n            // If a custom ordering is being used\n            if (this.c.order.length > 0) {\n                // Make a new Array of panes based upon the order\n                this.s.panes = this.c.order.map(function (name) { return _this._findPane(name); });\n            }\n            // If this internal property is true then the DataTable has been initialised already\n            if (this.s.dt.settings()[0]._bInitComplete) {\n                this._startup(table);\n            }\n            else {\n                // Otherwise add the paneStartup function to the list of functions\n                // that are to be run when the table is initialised. This will garauntee that the\n                // panes are initialised before the init event and init Complete callback is fired\n                this.s.dt.settings()[0].aoInitComplete.push({\n                    fn: function () { return _this._startup(table); }\n                });\n            }\n        };\n        /**\n         * Sets the listeners for the collapse and show all buttons\n         * Also sets and performs checks on current panes to see if they are collapsed\n         */\n        SearchPanes.prototype._setCollapseListener = function () {\n            var _this = this;\n            this.dom.collapseAll.on('click.dtsps', function () {\n                _this._collapseAll();\n                _this.dom.collapseAll.addClass(_this.classes.disabledButton).attr('disabled', 'true');\n                _this.dom.showAll.removeClass(_this.classes.disabledButton).removeAttr('disabled');\n                _this.s.dt.state.save();\n            });\n            this.dom.showAll.on('click.dtsps', function () {\n                _this._showAll();\n                _this.dom.showAll.addClass(_this.classes.disabledButton).attr('disabled', 'true');\n                _this.dom.collapseAll.removeClass(_this.classes.disabledButton).removeAttr('disabled');\n                _this.s.dt.state.save();\n            });\n            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {\n                var pane = _a[_i];\n                // We want to make the same check whenever there is a collapse/expand\n                pane.dom.topRow.on('collapse.dtsps', function () { return _this._checkCollapse(); });\n            }\n            this._checkCollapse();\n        };\n        /**\n         * Shows all of the panes\n         */\n        SearchPanes.prototype._showAll = function () {\n            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {\n                var pane = _a[_i];\n                pane.show();\n            }\n        };\n        /**\n         * Initialises the tables previous/preset selections and initialises callbacks for events\n         *\n         * @param table the parent table for which the searchPanes are being created\n         */\n        SearchPanes.prototype._startup = function (table) {\n            var _this = this;\n            // Attach clear button and title bar to the document\n            this._attach();\n            this.dom.panes.empty();\n            var hostSettings = this.s.dt.settings()[0];\n            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {\n                var pane = _a[_i];\n                pane.rebuildPane(Object.keys(this.s.serverData).length > 0 ? this.s.serverData : undefined);\n                this.dom.panes.append(pane.dom.container);\n            }\n            // If the layout is set to auto then the panes need to be resized to their best fit\n            if (this.c.layout === 'auto') {\n                this.resizePanes();\n            }\n            var loadedFilter = this.s.dt.state.loaded();\n            // Reset the paging if that has been saved in the state\n            if (!this.s.stateRead && loadedFilter) {\n                this.s.dt\n                    .page(loadedFilter.start / this.s.dt.page.len())\n                    .draw('page');\n            }\n            this.s.stateRead = true;\n            this._checkMessage();\n            // When a draw is called on the DataTable, update all of the panes incase the data in the DataTable has changed\n            table.on('preDraw.dtsps', function () {\n                // Check that the panes are not updating to avoid infinite loops\n                // Also check that this draw is not due to paging\n                if (!_this.s.updating && !_this.s.paging) {\n                    _this._updateFilterCount();\n                    _this._updateSelection();\n                }\n                // Paging flag reset - we only need to dodge the draw once\n                _this.s.paging = false;\n            });\n            $$1(window).on('resize.dtsps', dataTable$1.util.throttle(function () { return _this.resizePanes(); }));\n            // Whenever a state save occurs store the selection list in the state object\n            this.s.dt.on('stateSaveParams.dtsps', function (e, settings, data) {\n                if (settings !== hostSettings) {\n                    return;\n                }\n                if (data.searchPanes === undefined) {\n                    data.searchPanes = {};\n                }\n                data.searchPanes.selectionList = _this.s.selectionList;\n            });\n            this._stateLoadListener();\n            // Listener for paging on main table\n            table.off('page.dtsps page-nc.dtsps').on('page.dtsps page-nc.dtsps', function (e, s) {\n                _this.s.paging = true;\n                // This is an indicator to any selection tracking classes that paging has occured\n                // It has to happen here so that we don't stack event listeners unnecessarily\n                // The value is only ever set back to false in the SearchPanesST class\n                // Equally it is never read in this class\n                _this.s.pagingST = true;\n                _this.s.page = _this.s.dt.page();\n            });\n            if (this.s.dt.page.info().serverSide) {\n                table.off('preXhr.dtsps').on('preXhr.dtsps', function (e, settings, data) {\n                    if (settings !== hostSettings) {\n                        return;\n                    }\n                    if (!data.searchPanes) {\n                        data.searchPanes = {};\n                    }\n                    if (!data.searchPanes_null) {\n                        data.searchPanes_null = {};\n                    }\n                    // Count how many filters are being applied\n                    var filterCount = 0;\n                    for (var _i = 0, _a = _this.s.panes; _i < _a.length; _i++) {\n                        var pane = _a[_i];\n                        var src = _this.s.dt.column(pane.s.index).dataSrc();\n                        if (!data.searchPanes[src]) {\n                            data.searchPanes[src] = {};\n                        }\n                        if (!data.searchPanes_null[src]) {\n                            data.searchPanes_null[src] = {};\n                        }\n                        if (pane.s.dtPane) {\n                            var rowData = pane.s.dtPane.rows({ selected: true }).data().toArray();\n                            for (var i = 0; i < rowData.length; i++) {\n                                data.searchPanes[src][i] = rowData[i].filter;\n                                if (!data.searchPanes[src][i]) {\n                                    data.searchPanes_null[src][i] = true;\n                                }\n                                filterCount++;\n                            }\n                        }\n                    }\n                    // If there is a filter to be applied, then we need to read from the start of the result set\n                    // and set the paging to 0. This matches the behaviour of client side processing\n                    if (filterCount > 0) {\n                        // If the number of filters has changed we need to read from the start of the\n                        // result set and reset the paging\n                        if (filterCount !== _this.s.filterCount) {\n                            data.start = 0;\n                            _this.s.page = 0;\n                        }\n                        // Otherwise it is a paging request and we need to read from whatever the paging has been set to\n                        else {\n                            data.start = _this.s.page * _this.s.dt.page.len();\n                        }\n                        _this.s.dt.page(_this.s.page);\n                        _this.s.filterCount = filterCount;\n                    }\n                    if (_this.s.selectionList.length > 0) {\n                        data.searchPanesLast = _this.s.dt\n                            .column(_this.s.selectionList[_this.s.selectionList.length - 1].column)\n                            .dataSrc();\n                    }\n                    // Config options that will change how the querying is done\n                    data.searchPanes_options = {\n                        cascade: _this.c.cascadePanes,\n                        viewCount: _this.c.viewCount,\n                        viewTotal: _this.c.viewTotal\n                    };\n                });\n            }\n            else {\n                table.on('preXhr.dtsps', function () { return _this.s.panes.forEach(function (pane) { return pane.clearData(); }); });\n            }\n            // If the data is reloaded from the server then it is possible that it has changed completely,\n            // so we need to rebuild the panes\n            this.s.dt.on('xhr.dtsps', function (e, settings) {\n                if (settings.nTable !== _this.s.dt.table().node()) {\n                    return;\n                }\n                if (!_this.s.dt.page.info().serverSide) {\n                    var processing_1 = false;\n                    _this.s.dt.one('preDraw.dtsps', function () {\n                        if (processing_1) {\n                            return;\n                        }\n                        var page = _this.s.dt.page();\n                        processing_1 = true;\n                        _this.s.updating = true;\n                        _this.dom.panes.empty();\n                        for (var _i = 0, _a = _this.s.panes; _i < _a.length; _i++) {\n                            var pane = _a[_i];\n                            pane.clearData(); // Clears all of the bins and will mean that the data has to be re-read\n                            // Pass a boolean to say whether this is the last choice made for maintaining selections\n                            // when rebuilding\n                            pane.rebuildPane(undefined, true);\n                            _this.dom.panes.append(pane.dom.container);\n                        }\n                        if (!_this.s.dt.page.info().serverSide) {\n                            _this.s.dt.draw();\n                        }\n                        _this.s.updating = false;\n                        _this._updateSelection();\n                        _this._checkMessage();\n                        _this.s.dt.one('draw.dtsps', function () {\n                            _this.s.updating = true;\n                            _this.s.dt.page(page).draw(false);\n                            _this.s.updating = false;\n                        });\n                    });\n                }\n            });\n            // PreSelect any selections which have been defined using the preSelect option\n            var selectList = this.c.preSelect;\n            if (loadedFilter && loadedFilter.searchPanes && loadedFilter.searchPanes.selectionList) {\n                selectList = loadedFilter.searchPanes.selectionList;\n            }\n            this._makeSelections(selectList);\n            // Update the title bar to show how many filters have been selected\n            this._updateFilterCount();\n            // If the table is destroyed and restarted then clear the selections so that they do not persist.\n            table.on('destroy.dtsps', function (e, settings) {\n                if (settings !== hostSettings) {\n                    return;\n                }\n                for (var _i = 0, _a = _this.s.panes; _i < _a.length; _i++) {\n                    var pane = _a[_i];\n                    pane.destroy();\n                }\n                table.off('.dtsps');\n                _this.dom.showAll.off('.dtsps');\n                _this.dom.clearAll.off('.dtsps');\n                _this.dom.collapseAll.off('.dtsps');\n                $$1(table.table().node()).off('.dtsps');\n                _this.dom.container.detach();\n                _this.clearSelections();\n            });\n            if (this.c.collapse) {\n                this._setCollapseListener();\n            }\n            // When the clear All button has been pressed clear all of the selections in the panes\n            if (this.c.clear) {\n                this.dom.clearAll.on('click.dtsps', function () { return _this.clearSelections(); });\n            }\n            hostSettings._searchPanes = this;\n            // This state save is required so that state is maintained over multiple refreshes if no actions are made\n            this.s.dt.state.save();\n        };\n        /**\n         * Updates the number of filters that have been applied in the title\n         */\n        SearchPanes.prototype._updateFilterCount = function () {\n            var filterCount = 0;\n            // Add the number of all of the filters throughout the panes\n            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {\n                var pane = _a[_i];\n                if (pane.s.dtPane) {\n                    filterCount += pane.getPaneCount();\n                }\n            }\n            // Run the message through the internationalisation method to improve readability\n            this.dom.title.html(this.s.dt.i18n('searchPanes.title', this.c.i18n.title, filterCount));\n            if (this.c.filterChanged && typeof this.c.filterChanged === 'function') {\n                this.c.filterChanged.call(this.s.dt, filterCount);\n            }\n            if (filterCount === 0) {\n                this.dom.clearAll.addClass(this.classes.disabledButton).attr('disabled', 'true');\n            }\n            else {\n                this.dom.clearAll.removeClass(this.classes.disabledButton).removeAttr('disabled');\n            }\n        };\n        SearchPanes.version = '2.1.2';\n        SearchPanes.classes = {\n            clear: 'dtsp-clear',\n            clearAll: 'dtsp-clearAll',\n            collapseAll: 'dtsp-collapseAll',\n            container: 'dtsp-searchPanes',\n            disabledButton: 'dtsp-disabledButton',\n            emptyMessage: 'dtsp-emptyMessage',\n            hide: 'dtsp-hidden',\n            panes: 'dtsp-panesContainer',\n            search: 'dtsp-search',\n            showAll: 'dtsp-showAll',\n            title: 'dtsp-title',\n            titleRow: 'dtsp-titleRow'\n        };\n        // Define SearchPanes default options\n        SearchPanes.defaults = {\n            cascadePanes: false,\n            clear: true,\n            collapse: true,\n            columns: [],\n            container: function (dt) {\n                return dt.table().container();\n            },\n            filterChanged: undefined,\n            i18n: {\n                clearMessage: 'Clear All',\n                clearPane: '&times;',\n                collapse: {\n                    0: 'SearchPanes',\n                    _: 'SearchPanes (%d)'\n                },\n                collapseMessage: 'Collapse All',\n                count: '{total}',\n                emptyMessage: '<em>No data</em>',\n                emptyPanes: 'No SearchPanes',\n                loadMessage: 'Loading Search Panes...',\n                showMessage: 'Show All',\n                title: 'Filters Active - %d'\n            },\n            layout: 'auto',\n            order: [],\n            panes: [],\n            preSelect: [],\n            viewCount: true,\n            viewTotal: false\n        };\n        return SearchPanes;\n    }());\n\n    var __extends = (window && window.__extends) || (function () {\n        var extendStatics = function (d, b) {\n            extendStatics = Object.setPrototypeOf ||\n                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n            return extendStatics(d, b);\n        };\n        return function (d, b) {\n            extendStatics(d, b);\n            function __() { this.constructor = d; }\n            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n        };\n    })();\n    var SearchPanesST = /** @class */ (function (_super) {\n        __extends(SearchPanesST, _super);\n        function SearchPanesST(paneSettings, opts, fromPreInit) {\n            if (fromPreInit === void 0) { fromPreInit = false; }\n            var _this = this;\n            var paneClass;\n            if (opts.cascadePanes && opts.viewTotal) {\n                paneClass = SearchPaneCascadeViewTotal;\n            }\n            else if (opts.cascadePanes) {\n                paneClass = SearchPaneCascade;\n            }\n            else if (opts.viewTotal) {\n                paneClass = SearchPaneViewTotal;\n            }\n            _this = _super.call(this, paneSettings, opts, fromPreInit, paneClass) || this;\n            var dt = _this.s.dt;\n            var loadedFilter = dt.state.loaded();\n            var loadFn = function () { return _this._initSelectionListeners(true, loadedFilter && loadedFilter.searchPanes && loadedFilter.searchPanes.selectionList ?\n                loadedFilter.searchPanes.selectionList :\n                _this.c.preSelect); };\n            if (dt.settings()[0]._bInitComplete) {\n                loadFn();\n            }\n            else {\n                dt.off('init.dtsps').on('init.dtsps', loadFn);\n            }\n            return _this;\n        }\n        /**\n         * Ensures that the correct selection listeners are set for selection tracking\n         *\n         * @param preSelect Any values that are to be preselected\n         */\n        SearchPanesST.prototype._initSelectionListeners = function (isPreselect, preSelect) {\n            if (isPreselect === void 0) { isPreselect = true; }\n            if (preSelect === void 0) { preSelect = []; }\n            if (isPreselect) {\n                this.s.selectionList = preSelect;\n            }\n            // Set selection listeners for each pane\n            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {\n                var pane = _a[_i];\n                if (pane.s.displayed) {\n                    pane.s.dtPane\n                        .off('select.dtsp')\n                        .on('select.dtsp', this._update(pane))\n                        .off('deselect.dtsp')\n                        .on('deselect.dtsp', this._updateTimeout(pane));\n                }\n            }\n            // Update on every draw\n            this.s.dt.off('draw.dtsps').on('draw.dtsps', this._update());\n            // Also update right now as table has just initialised\n            this._updateSelectionList();\n        };\n        /**\n         * Retrieve the total values from the server data\n         */\n        SearchPanesST.prototype._serverTotals = function () {\n            for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {\n                var pane = _a[_i];\n                if (pane.s.colOpts.show) {\n                    var colTitle = this.s.dt.column(pane.s.index).dataSrc();\n                    var blockVT = true;\n                    // If any of the counts are not equal to the totals filtering must be active\n                    if (this.s.serverData.searchPanes.options[colTitle]) {\n                        for (var _b = 0, _c = this.s.serverData.searchPanes.options[colTitle]; _b < _c.length; _b++) {\n                            var data = _c[_b];\n                            if (data.total !== data.count) {\n                                blockVT = false;\n                                break;\n                            }\n                        }\n                    }\n                    // Set if filtering is present on the pane and populate the data arrays\n                    pane.s.filteringActive = !blockVT;\n                    pane._serverPopulate(this.s.serverData);\n                }\n            }\n        };\n        /**\n         * Set's the function that is to be performed when a state is loaded\n         *\n         * Overrides the method in SearchPanes\n         */\n        SearchPanesST.prototype._stateLoadListener = function () {\n            var _this = this;\n            var stateLoadFunction = function (e, settings, data) {\n                if (data.searchPanes === undefined) {\n                    return;\n                }\n                // Set the selection list for the panes so that the correct\n                // rows can be reselected and in the right order\n                _this.s.selectionList =\n                    data.searchPanes.selectionList ?\n                        data.searchPanes.selectionList :\n                        [];\n                // Find the panes that match from the state and the actual instance\n                if (data.searchPanes.panes) {\n                    for (var _i = 0, _a = data.searchPanes.panes; _i < _a.length; _i++) {\n                        var loadedPane = _a[_i];\n                        for (var _b = 0, _c = _this.s.panes; _b < _c.length; _b++) {\n                            var pane = _c[_b];\n                            if (loadedPane.id === pane.s.index && pane.s.dtPane) {\n                                // Set the value of the searchbox\n                                pane.dom.searchBox.val(loadedPane.searchTerm);\n                                // Set the value of the order\n                                pane.s.dtPane.order(loadedPane.order);\n                            }\n                        }\n                    }\n                }\n                _this._updateSelectionList();\n            };\n            this.s.dt.off('stateLoadParams.dtsps', stateLoadFunction).on('stateLoadParams.dtsps', stateLoadFunction);\n        };\n        /**\n         * Remove the function's actions when using cascade\n         *\n         * Overrides the method in SearchPanes\n         */\n        SearchPanesST.prototype._updateSelection = function () {\n            return;\n        };\n        /**\n         * Returns a function that updates the selection list based on a specific pane\n         * Also clears the timeout to stop the deselect from running\n         *\n         * @param pane the pane that is to have it's selections loaded\n         */\n        SearchPanesST.prototype._update = function (pane) {\n            var _this = this;\n            if (pane === void 0) { pane = undefined; }\n            return function () {\n                if (pane) {\n                    clearTimeout(pane.s.deselectTimeout);\n                }\n                _this._updateSelectionList(pane);\n            };\n        };\n        /**\n         * Returns a function that updates the selection list based on a specific pane\n         * Also sets a timeout incase a select is about to be made\n         *\n         * @param pane the pane that is to have it's selections loaded\n         */\n        SearchPanesST.prototype._updateTimeout = function (pane) {\n            var _this = this;\n            if (pane === void 0) { pane = undefined; }\n            return function () { return pane ?\n                pane.s.deselectTimeout = setTimeout(function () { return _this._updateSelectionList(pane); }, 50) :\n                _this._updateSelectionList(); };\n        };\n        /**\n         * Updates the selection list to include the latest selections for a given pane\n         *\n         * @param index The index of the pane that is to be updated\n         * @param selected Which rows are selected within the pane\n         */\n        SearchPanesST.prototype._updateSelectionList = function (paneIn) {\n            if (paneIn === void 0) { paneIn = undefined; }\n            // Bail if any of these flags are set\n            if (this.s.pagingST) {\n                // Reset pagingST flag\n                this.s.pagingST = false;\n                return;\n            }\n            else if (this.s.updating || paneIn && paneIn.s.serverSelecting) {\n                return;\n            }\n            if (paneIn !== undefined) {\n                if (this.s.dt.page.info().serverSide) {\n                    paneIn._updateSelection();\n                }\n                // Get filter values for all of the rows and the selections\n                var rows = paneIn.s.dtPane.rows({ selected: true }).data().toArray().map(function (el) { return el.filter; });\n                this.s.selectionList = this.s.selectionList.filter(function (selection) { return selection.column !== paneIn.s.index; });\n                if (rows.length > 0) {\n                    this.s.selectionList.push({\n                        column: paneIn.s.index,\n                        rows: rows\n                    });\n                    paneIn.dom.clear.removeClass(this.classes.disabledButton).removeAttr('disabled');\n                }\n                else {\n                    paneIn.dom.clear.addClass(this.classes.disabledButton).attr('disabled', 'true');\n                }\n                if (this.s.dt.page.info().serverSide) {\n                    this.s.dt.draw(false);\n                }\n            }\n            this._remakeSelections();\n            this._updateFilterCount();\n        };\n        /**\n         * Remake the selections that were present before new data or calculations have occured\n         */\n        SearchPanesST.prototype._remakeSelections = function () {\n            this.s.updating = true;\n            if (!this.s.dt.page.info().serverSide) {\n                var tmpSL = this.s.selectionList;\n                var anotherFilter = false;\n                this.clearSelections();\n                this.s.dt.draw(false);\n                // When there are no selections present if the length of the data does not match the searched data\n                // then another filter is present\n                if (this.s.dt.rows().toArray()[0].length > this.s.dt.rows({ search: 'applied' }).toArray()[0].length) {\n                    anotherFilter = true;\n                }\n                this.s.selectionList = tmpSL;\n                // Update the rows in each pane\n                for (var _i = 0, _a = this.s.panes; _i < _a.length; _i++) {\n                    var pane = _a[_i];\n                    if (pane.s.displayed) {\n                        pane.s.filteringActive = anotherFilter;\n                        pane.updateRows();\n                    }\n                }\n                for (var _b = 0, _c = this.s.selectionList; _b < _c.length; _b++) {\n                    var selection = _c[_b];\n                    var pane = void 0;\n                    for (var _d = 0, _e = this.s.panes; _d < _e.length; _d++) {\n                        var paneCheck = _e[_d];\n                        if (paneCheck.s.index === selection.column) {\n                            pane = paneCheck;\n                            break;\n                        }\n                    }\n                    if (!pane.s.dtPane) {\n                        continue;\n                    }\n                    var ids = pane.s.dtPane.rows().indexes().toArray();\n                    // Select the rows that are present in the selection list\n                    for (var i = 0; i < selection.rows.length; i++) {\n                        var rowFound = false;\n                        for (var _f = 0, ids_1 = ids; _f < ids_1.length; _f++) {\n                            var id = ids_1[_f];\n                            var currRow = pane.s.dtPane.row(id);\n                            var data = currRow.data();\n                            if (selection.rows[i] === data.filter) {\n                                currRow.select();\n                                rowFound = true;\n                            }\n                        }\n                        if (!rowFound) {\n                            selection.rows.splice(i, 1);\n                            i--;\n                        }\n                    }\n                    pane.s.selections = selection.rows;\n                    // If there are no rows selected then don't bother continuing past here\n                    // Will just increase processing time and skew the rows that are shown in the table\n                    if (selection.rows.length === 0) {\n                        continue;\n                    }\n                    // Update the table to display the current results\n                    this.s.dt.draw(false);\n                    var filteringActive = false;\n                    var filterCount = 0;\n                    var prevSelectedPanes = 0;\n                    var selectedPanes = 0;\n                    // Add the number of all of the filters throughout the panes\n                    for (var _g = 0, _h = this.s.panes; _g < _h.length; _g++) {\n                        var currPane = _h[_g];\n                        if (currPane.s.dtPane) {\n                            filterCount += currPane.getPaneCount();\n                            if (filterCount > prevSelectedPanes) {\n                                selectedPanes++;\n                                prevSelectedPanes = filterCount;\n                            }\n                        }\n                    }\n                    filteringActive = filterCount > 0;\n                    for (var _j = 0, _k = this.s.panes; _j < _k.length; _j++) {\n                        var currPane = _k[_j];\n                        if (currPane.s.displayed) {\n                            // Set the filtering active flag\n                            if (anotherFilter || pane.s.index !== currPane.s.index || !filteringActive) {\n                                currPane.s.filteringActive = filteringActive || anotherFilter;\n                            }\n                            else if (selectedPanes === 1) {\n                                currPane.s.filteringActive = false;\n                            }\n                            // Update the rows to show correct counts\n                            if (currPane.s.index !== pane.s.index) {\n                                currPane.updateRows();\n                            }\n                        }\n                    }\n                }\n                // Update table to show final search results\n                this.s.dt.draw(false);\n            }\n            else {\n                // Identify the last pane to have a change in selection\n                var pane = void 0;\n                if (this.s.selectionList.length > 0) {\n                    pane = this.s.panes[this.s.selectionList[this.s.selectionList.length - 1].column];\n                }\n                // Update the rows of all of the other panes\n                for (var _l = 0, _m = this.s.panes; _l < _m.length; _l++) {\n                    var currPane = _m[_l];\n                    if (currPane.s.displayed && (!pane || currPane.s.index !== pane.s.index)) {\n                        currPane.updateRows();\n                    }\n                }\n            }\n            this.s.updating = false;\n        };\n        return SearchPanesST;\n    }(SearchPanes));\n\n    /*! SearchPanes 2.1.2\n     * © SpryMedia Ltd - datatables.net/license\n     */\n    setJQuery$4($);\n    setJQuery($);\n    setJQuery$3($);\n    setJQuery$2($);\n    setJQuery$1($);\n    var dataTable = $.fn.dataTable;\n    // eslint-disable-next-line no-extra-parens\n    dataTable.SearchPanes = SearchPanes;\n    // eslint-disable-next-line no-extra-parens\n    DataTable.SearchPanes = SearchPanes;\n    // eslint-disable-next-line no-extra-parens\n    dataTable.SearchPanesST = SearchPanesST;\n    // eslint-disable-next-line no-extra-parens\n    DataTable.SearchPanesST = SearchPanesST;\n    // eslint-disable-next-line no-extra-parens\n    dataTable.SearchPane = SearchPane;\n    // eslint-disable-next-line no-extra-parens\n    DataTable.SearchPane = SearchPane;\n    // eslint-disable-next-line no-extra-parens\n    dataTable.SearchPaneViewTotal = SearchPaneViewTotal;\n    // eslint-disable-next-line no-extra-parens\n    DataTable.SearchPaneViewTotal = SearchPaneViewTotal;\n    // eslint-disable-next-line no-extra-parens\n    dataTable.SearchPaneCascade = SearchPaneCascade;\n    // eslint-disable-next-line no-extra-parens\n    DataTable.SearchPaneCascade = SearchPaneCascade;\n    // eslint-disable-next-line no-extra-parens\n    dataTable.SearchPaneCascadeViewTotal = SearchPaneCascadeViewTotal;\n    // eslint-disable-next-line no-extra-parens\n    DataTable.SearchPaneCascadeViewTotal = SearchPaneCascadeViewTotal;\n    // eslint-disable-next-line no-extra-parens\n    var apiRegister = $.fn.dataTable.Api.register;\n    apiRegister('searchPanes()', function () {\n        return this;\n    });\n    apiRegister('searchPanes.clearSelections()', function () {\n        return this.iterator('table', function (ctx) {\n            if (ctx._searchPanes) {\n                ctx._searchPanes.clearSelections();\n            }\n        });\n    });\n    apiRegister('searchPanes.rebuildPane()', function (targetIdx, maintainSelections) {\n        return this.iterator('table', function (ctx) {\n            if (ctx._searchPanes) {\n                ctx._searchPanes.rebuild(targetIdx, maintainSelections);\n            }\n        });\n    });\n    apiRegister('searchPanes.resizePanes()', function () {\n        var ctx = this.context[0];\n        return ctx._searchPanes ?\n            ctx._searchPanes.resizePanes() :\n            null;\n    });\n    apiRegister('searchPanes.container()', function () {\n        var ctx = this.context[0];\n        return ctx._searchPanes\n            ? ctx._searchPanes.getNode()\n            : null;\n    });\n    DataTable.ext.buttons.searchPanesClear = {\n        action: function (e, dt) {\n            dt.searchPanes.clearSelections();\n        },\n        text: 'Clear Panes'\n    };\n    DataTable.ext.buttons.searchPanes = {\n        action: function (e, dt, node, config) {\n            var _this = this;\n            if (!config._panes) {\n                // No SearchPanes on this button yet - initialise and show\n                this.processing(true);\n                setTimeout(function () {\n                    _buttonSourced(dt, node, config);\n                    _this.popover(config._panes.getNode(), {\n                        align: 'container',\n                        span: 'container'\n                    });\n                    config._panes.rebuild(undefined, true);\n                    _this.processing(false);\n                }, 10);\n            }\n            else {\n                // Already got SP - show it\n                this.popover(config._panes.getNode(), {\n                    align: 'container',\n                    span: 'container'\n                });\n                config._panes.rebuild(undefined, true);\n            }\n        },\n        init: function (dt, node, config) {\n            dt.button(node).text(config.text || dt.i18n('searchPanes.collapse', 'SearchPanes', 0));\n            // If state save is enabled, we need to initialise SP immediately\n            // to allow any saved state to be restored. Otherwise we can delay\n            // the init until needed by button press\n            if (dt.init().stateSave) {\n                _buttonSourced(dt, node, config);\n            }\n        },\n        config: {},\n        text: ''\n    };\n    function _buttonSourced(dt, node, config) {\n        var buttonOpts = $.extend({\n            filterChanged: function (count) {\n                dt.button(node).text(dt.i18n('searchPanes.collapse', dt.context[0].oLanguage.searchPanes !== undefined ?\n                    dt.context[0].oLanguage.searchPanes.collapse :\n                    dt.context[0]._searchPanes.c.i18n.collapse, count));\n            }\n        }, config.config);\n        var panes = buttonOpts && (buttonOpts.cascadePanes || buttonOpts.viewTotal) ?\n            new DataTable.SearchPanesST(dt, buttonOpts) :\n            new DataTable.SearchPanes(dt, buttonOpts);\n        dt.button(node).text(config.text || dt.i18n('searchPanes.collapse', panes.c.i18n.collapse, 0));\n        config._panes = panes;\n    }\n    function _init(settings, options, fromPre) {\n        if (options === void 0) { options = null; }\n        if (fromPre === void 0) { fromPre = false; }\n        var api = new dataTable.Api(settings);\n        var opts = options\n            ? options\n            : api.init().searchPanes || dataTable.defaults.searchPanes;\n        var searchPanes = opts && (opts.cascadePanes || opts.viewTotal) ?\n            new SearchPanesST(api, opts, fromPre) :\n            new SearchPanes(api, opts, fromPre);\n        var node = searchPanes.getNode();\n        return node;\n    }\n    // Attach a listener to the document which listens for DataTables initialisation\n    // events so we can automatically initialise\n    $(document).on('preInit.dt.dtsp', function (e, settings) {\n        if (e.namespace !== 'dt') {\n            return;\n        }\n        if (settings.oInit.searchPanes ||\n            DataTable.defaults.searchPanes) {\n            if (!settings._searchPanes) {\n                _init(settings, null, true);\n            }\n        }\n    });\n    // DataTables `dom` feature option\n    DataTable.ext.feature.push({\n        cFeature: 'P',\n        fnInit: _init\n    });\n    // DataTables 2 layout feature\n    if (DataTable.ext.features) {\n        DataTable.ext.features.register('searchPanes', _init);\n    }\n\n})();\n\n\nexport default DataTable;\n","/*! Bootstrap 5 styling wrapper for Select\n * © SpryMedia Ltd - datatables.net/license\n */\n\nimport $ from 'jquery';\nimport DataTable from 'datatables.net-bs5';\nimport select from 'datatables.net-select';\n\n\n\nexport default DataTable;\n","/*! Select for DataTables 1.6.2\n * © SpryMedia Ltd - datatables.net/license/mit\n */\n\nimport $ from 'jquery';\nimport DataTable from 'datatables.net';\n\n\n// Version information for debugger\nDataTable.select = {};\n\nDataTable.select.version = '1.6.2';\n\nDataTable.select.init = function ( dt ) {\n\tvar ctx = dt.settings()[0];\n\n\tif (ctx._select) {\n\t\treturn;\n\t}\n\n\tvar savedSelected = dt.state.loaded();\n\n\tvar selectAndSave = function(e, settings, data) {\n\t\tif(data === null || data.select === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Clear any currently selected rows, before restoring state\n\t\t// None will be selected on first initialisation\n\t\tif (dt.rows({selected: true}).any()) {\n\t\t\tdt.rows().deselect();\n\t\t}\n\t\tif (data.select.rows !== undefined) {\n\t\t\tdt.rows(data.select.rows).select();\n\t\t}\n\n\t\tif (dt.columns({selected: true}).any()) {\n\t\t\tdt.columns().deselect();\n\t\t}\n\t\tif (data.select.columns !== undefined) {\n\t\t\tdt.columns(data.select.columns).select();\n\t\t}\n\n\t\tif (dt.cells({selected: true}).any()) {\n\t\t\tdt.cells().deselect();\n\t\t}\n\t\tif (data.select.cells !== undefined) {\n\t\t\tfor(var i = 0; i < data.select.cells.length; i++) {\n\t\t\t\tdt.cell(data.select.cells[i].row, data.select.cells[i].column).select();\n\t\t\t}\n\t\t}\n\n\t\tdt.state.save();\n\t}\n\t\n\tdt\n\t\t.on('stateSaveParams', function(e, settings, data) {\n\t\t\tdata.select = {};\n\t\t\tdata.select.rows = dt.rows({selected:true}).ids(true).toArray();\n\t\t\tdata.select.columns = dt.columns({selected:true})[0];\n\t\t\tdata.select.cells = dt.cells({selected:true})[0].map(function(coords) {\n\t\t\t\treturn {row: dt.row(coords.row).id(true), column: coords.column}\n\t\t\t});\n\t\t})\n\t\t.on('stateLoadParams', selectAndSave)\n\t\t.one('init', function() {\n\t\t\tselectAndSave(undefined, undefined, savedSelected);\n\t\t});\n\n\tvar init = ctx.oInit.select;\n\tvar defaults = DataTable.defaults.select;\n\tvar opts = init === undefined ?\n\t\tdefaults :\n\t\tinit;\n\n\t// Set defaults\n\tvar items = 'row';\n\tvar style = 'api';\n\tvar blurable = false;\n\tvar toggleable = true;\n\tvar info = true;\n\tvar selector = 'td, th';\n\tvar className = 'selected';\n\tvar setStyle = false;\n\n\tctx._select = {};\n\n\t// Initialisation customisations\n\tif ( opts === true ) {\n\t\tstyle = 'os';\n\t\tsetStyle = true;\n\t}\n\telse if ( typeof opts === 'string' ) {\n\t\tstyle = opts;\n\t\tsetStyle = true;\n\t}\n\telse if ( $.isPlainObject( opts ) ) {\n\t\tif ( opts.blurable !== undefined ) {\n\t\t\tblurable = opts.blurable;\n\t\t}\n\t\t\n\t\tif ( opts.toggleable !== undefined ) {\n\t\t\ttoggleable = opts.toggleable;\n\t\t}\n\n\t\tif ( opts.info !== undefined ) {\n\t\t\tinfo = opts.info;\n\t\t}\n\n\t\tif ( opts.items !== undefined ) {\n\t\t\titems = opts.items;\n\t\t}\n\n\t\tif ( opts.style !== undefined ) {\n\t\t\tstyle = opts.style;\n\t\t\tsetStyle = true;\n\t\t}\n\t\telse {\n\t\t\tstyle = 'os';\n\t\t\tsetStyle = true;\n\t\t}\n\n\t\tif ( opts.selector !== undefined ) {\n\t\t\tselector = opts.selector;\n\t\t}\n\n\t\tif ( opts.className !== undefined ) {\n\t\t\tclassName = opts.className;\n\t\t}\n\t}\n\n\tdt.select.selector( selector );\n\tdt.select.items( items );\n\tdt.select.style( style );\n\tdt.select.blurable( blurable );\n\tdt.select.toggleable( toggleable );\n\tdt.select.info( info );\n\tctx._select.className = className;\n\n\n\t// Sort table based on selected rows. Requires Select Datatables extension\n\t$.fn.dataTable.ext.order['select-checkbox'] = function ( settings, col ) {\n\t\treturn this.api().column( col, {order: 'index'} ).nodes().map( function ( td ) {\n\t\t\tif ( settings._select.items === 'row' ) {\n\t\t\t\treturn $( td ).parent().hasClass( settings._select.className );\n\t\t\t} else if ( settings._select.items === 'cell' ) {\n\t\t\t\treturn $( td ).hasClass( settings._select.className );\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t};\n\n\t// If the init options haven't enabled select, but there is a selectable\n\t// class name, then enable\n\tif ( ! setStyle && $( dt.table().node() ).hasClass( 'selectable' ) ) {\n\t\tdt.select.style( 'os' );\n\t}\n};\n\n/*\n\nSelect is a collection of API methods, event handlers, event emitters and\nbuttons (for the `Buttons` extension) for DataTables. It provides the following\nfeatures, with an overview of how they are implemented:\n\n## Selection of rows, columns and cells. Whether an item is selected or not is\n   stored in:\n\n* rows: a `_select_selected` property which contains a boolean value of the\n  DataTables' `aoData` object for each row\n* columns: a `_select_selected` property which contains a boolean value of the\n  DataTables' `aoColumns` object for each column\n* cells: a `_selected_cells` property which contains an array of boolean values\n  of the `aoData` object for each row. The array is the same length as the\n  columns array, with each element of it representing a cell.\n\nThis method of using boolean flags allows Select to operate when nodes have not\nbeen created for rows / cells (DataTables' defer rendering feature).\n\n## API methods\n\nA range of API methods are available for triggering selection and de-selection\nof rows. Methods are also available to configure the selection events that can\nbe triggered by an end user (such as which items are to be selected). To a large\nextent, these of API methods *is* Select. It is basically a collection of helper\nfunctions that can be used to select items in a DataTable.\n\nConfiguration of select is held in the object `_select` which is attached to the\nDataTables settings object on initialisation. Select being available on a table\nis not optional when Select is loaded, but its default is for selection only to\nbe available via the API - so the end user wouldn't be able to select rows\nwithout additional configuration.\n\nThe `_select` object contains the following properties:\n\n```\n{\n\titems:string       - Can be `rows`, `columns` or `cells`. Defines what item \n\t                     will be selected if the user is allowed to activate row\n\t                     selection using the mouse.\n\tstyle:string       - Can be `none`, `single`, `multi` or `os`. Defines the\n\t                     interaction style when selecting items\n\tblurable:boolean   - If row selection can be cleared by clicking outside of\n\t                     the table\n\ttoggleable:boolean - If row selection can be cancelled by repeated clicking\n\t                     on the row\n\tinfo:boolean       - If the selection summary should be shown in the table\n\t                     information elements\n}\n```\n\nIn addition to the API methods, Select also extends the DataTables selector\noptions for rows, columns and cells adding a `selected` option to the selector\noptions object, allowing the developer to select only selected items or\nunselected items.\n\n## Mouse selection of items\n\nClicking on items can be used to select items. This is done by a simple event\nhandler that will select the items using the API methods.\n\n */\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Local functions\n */\n\n/**\n * Add one or more cells to the selection when shift clicking in OS selection\n * style cell selection.\n *\n * Cell range is more complicated than row and column as we want to select\n * in the visible grid rather than by index in sequence. For example, if you\n * click first in cell 1-1 and then shift click in 2-2 - cells 1-2 and 2-1\n * should also be selected (and not 1-3, 1-4. etc)\n * \n * @param  {DataTable.Api} dt   DataTable\n * @param  {object}        idx  Cell index to select to\n * @param  {object}        last Cell index to select from\n * @private\n */\nfunction cellRange( dt, idx, last )\n{\n\tvar indexes;\n\tvar columnIndexes;\n\tvar rowIndexes;\n\tvar selectColumns = function ( start, end ) {\n\t\tif ( start > end ) {\n\t\t\tvar tmp = end;\n\t\t\tend = start;\n\t\t\tstart = tmp;\n\t\t}\n\t\t\n\t\tvar record = false;\n\t\treturn dt.columns( ':visible' ).indexes().filter( function (i) {\n\t\t\tif ( i === start ) {\n\t\t\t\trecord = true;\n\t\t\t}\n\t\t\t\n\t\t\tif ( i === end ) { // not else if, as start might === end\n\t\t\t\trecord = false;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn record;\n\t\t} );\n\t};\n\n\tvar selectRows = function ( start, end ) {\n\t\tvar indexes = dt.rows( { search: 'applied' } ).indexes();\n\n\t\t// Which comes first - might need to swap\n\t\tif ( indexes.indexOf( start ) > indexes.indexOf( end ) ) {\n\t\t\tvar tmp = end;\n\t\t\tend = start;\n\t\t\tstart = tmp;\n\t\t}\n\n\t\tvar record = false;\n\t\treturn indexes.filter( function (i) {\n\t\t\tif ( i === start ) {\n\t\t\t\trecord = true;\n\t\t\t}\n\t\t\t\n\t\t\tif ( i === end ) {\n\t\t\t\trecord = false;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn record;\n\t\t} );\n\t};\n\n\tif ( ! dt.cells( { selected: true } ).any() && ! last ) {\n\t\t// select from the top left cell to this one\n\t\tcolumnIndexes = selectColumns( 0, idx.column );\n\t\trowIndexes = selectRows( 0 , idx.row );\n\t}\n\telse {\n\t\t// Get column indexes between old and new\n\t\tcolumnIndexes = selectColumns( last.column, idx.column );\n\t\trowIndexes = selectRows( last.row , idx.row );\n\t}\n\n\tindexes = dt.cells( rowIndexes, columnIndexes ).flatten();\n\n\tif ( ! dt.cells( idx, { selected: true } ).any() ) {\n\t\t// Select range\n\t\tdt.cells( indexes ).select();\n\t}\n\telse {\n\t\t// Deselect range\n\t\tdt.cells( indexes ).deselect();\n\t}\n}\n\n/**\n * Disable mouse selection by removing the selectors\n *\n * @param {DataTable.Api} dt DataTable to remove events from\n * @private\n */\nfunction disableMouseSelection( dt )\n{\n\tvar ctx = dt.settings()[0];\n\tvar selector = ctx._select.selector;\n\n\t$( dt.table().container() )\n\t\t.off( 'mousedown.dtSelect', selector )\n\t\t.off( 'mouseup.dtSelect', selector )\n\t\t.off( 'click.dtSelect', selector );\n\n\t$('body').off( 'click.dtSelect' + _safeId(dt.table().node()) );\n}\n\n/**\n * Attach mouse listeners to the table to allow mouse selection of items\n *\n * @param {DataTable.Api} dt DataTable to remove events from\n * @private\n */\nfunction enableMouseSelection ( dt )\n{\n\tvar container = $( dt.table().container() );\n\tvar ctx = dt.settings()[0];\n\tvar selector = ctx._select.selector;\n\tvar matchSelection;\n\n\tcontainer\n\t\t.on( 'mousedown.dtSelect', selector, function(e) {\n\t\t\t// Disallow text selection for shift clicking on the table so multi\n\t\t\t// element selection doesn't look terrible!\n\t\t\tif ( e.shiftKey || e.metaKey || e.ctrlKey ) {\n\t\t\t\tcontainer\n\t\t\t\t\t.css( '-moz-user-select', 'none' )\n\t\t\t\t\t.one('selectstart.dtSelect', selector, function () {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} );\n\t\t\t}\n\n\t\t\tif ( window.getSelection ) {\n\t\t\t\tmatchSelection = window.getSelection();\n\t\t\t}\n\t\t} )\n\t\t.on( 'mouseup.dtSelect', selector, function() {\n\t\t\t// Allow text selection to occur again, Mozilla style (tested in FF\n\t\t\t// 35.0.1 - still required)\n\t\t\tcontainer.css( '-moz-user-select', '' );\n\t\t} )\n\t\t.on( 'click.dtSelect', selector, function ( e ) {\n\t\t\tvar items = dt.select.items();\n\t\t\tvar idx;\n\n\t\t\t// If text was selected (click and drag), then we shouldn't change\n\t\t\t// the row's selected state\n\t\t\tif ( matchSelection ) {\n\t\t\t\tvar selection = window.getSelection();\n\n\t\t\t\t// If the element that contains the selection is not in the table, we can ignore it\n\t\t\t\t// This can happen if the developer selects text from the click event\n\t\t\t\tif ( ! selection.anchorNode || $(selection.anchorNode).closest('table')[0] === dt.table().node() ) {\n\t\t\t\t\tif ( selection !== matchSelection ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar ctx = dt.settings()[0];\n\t\t\tvar wrapperClass = dt.settings()[0].oClasses.sWrapper.trim().replace(/ +/g, '.');\n\n\t\t\t// Ignore clicks inside a sub-table\n\t\t\tif ( $(e.target).closest('div.'+wrapperClass)[0] != dt.table().container() ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar cell = dt.cell( $(e.target).closest('td, th') );\n\n\t\t\t// Check the cell actually belongs to the host DataTable (so child\n\t\t\t// rows, etc, are ignored)\n\t\t\tif ( ! cell.any() ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar event = $.Event('user-select.dt');\n\t\t\teventTrigger( dt, event, [ items, cell, e ] );\n\n\t\t\tif ( event.isDefaultPrevented() ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar cellIndex = cell.index();\n\t\t\tif ( items === 'row' ) {\n\t\t\t\tidx = cellIndex.row;\n\t\t\t\ttypeSelect( e, dt, ctx, 'row', idx );\n\t\t\t}\n\t\t\telse if ( items === 'column' ) {\n\t\t\t\tidx = cell.index().column;\n\t\t\t\ttypeSelect( e, dt, ctx, 'column', idx );\n\t\t\t}\n\t\t\telse if ( items === 'cell' ) {\n\t\t\t\tidx = cell.index();\n\t\t\t\ttypeSelect( e, dt, ctx, 'cell', idx );\n\t\t\t}\n\n\t\t\tctx._select_lastCell = cellIndex;\n\t\t} );\n\n\t// Blurable\n\t$('body').on( 'click.dtSelect' + _safeId(dt.table().node()), function ( e ) {\n\t\tif ( ctx._select.blurable ) {\n\t\t\t// If the click was inside the DataTables container, don't blur\n\t\t\tif ( $(e.target).parents().filter( dt.table().container() ).length ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Ignore elements which have been removed from the DOM (i.e. paging\n\t\t\t// buttons)\n\t\t\tif ( $(e.target).parents('html').length === 0 ) {\n\t\t\t \treturn;\n\t\t\t}\n\n\t\t\t// Don't blur in Editor form\n\t\t\tif ( $(e.target).parents('div.DTE').length ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar event = $.Event('select-blur.dt');\n\t\t\teventTrigger( dt, event, [ e.target, e ] );\n\n\t\t\tif ( event.isDefaultPrevented() ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclear( ctx, true );\n\t\t}\n\t} );\n}\n\n/**\n * Trigger an event on a DataTable\n *\n * @param {DataTable.Api} api      DataTable to trigger events on\n * @param  {boolean}      selected true if selected, false if deselected\n * @param  {string}       type     Item type acting on\n * @param  {boolean}      any      Require that there are values before\n *     triggering\n * @private\n */\nfunction eventTrigger ( api, type, args, any )\n{\n\tif ( any && ! api.flatten().length ) {\n\t\treturn;\n\t}\n\n\tif ( typeof type === 'string' ) {\n\t\ttype = type +'.dt';\n\t}\n\n\targs.unshift( api );\n\n\t$(api.table().node()).trigger( type, args );\n}\n\n/**\n * Update the information element of the DataTable showing information about the\n * items selected. This is done by adding tags to the existing text\n * \n * @param {DataTable.Api} api DataTable to update\n * @private\n */\nfunction info ( api )\n{\n\tvar ctx = api.settings()[0];\n\n\tif ( ! ctx._select.info || ! ctx.aanFeatures.i ) {\n\t\treturn;\n\t}\n\n\tif ( api.select.style() === 'api' ) {\n\t\treturn;\n\t}\n\n\tvar rows    = api.rows( { selected: true } ).flatten().length;\n\tvar columns = api.columns( { selected: true } ).flatten().length;\n\tvar cells   = api.cells( { selected: true } ).flatten().length;\n\n\tvar add = function ( el, name, num ) {\n\t\tel.append( $('<span class=\"select-item\"/>').append( api.i18n(\n\t\t\t'select.'+name+'s',\n\t\t\t{ _: '%d '+name+'s selected', 0: '', 1: '1 '+name+' selected' },\n\t\t\tnum\n\t\t) ) );\n\t};\n\n\t// Internal knowledge of DataTables to loop over all information elements\n\t$.each( ctx.aanFeatures.i, function ( i, el ) {\n\t\tel = $(el);\n\n\t\tvar output  = $('<span class=\"select-info\"/>');\n\t\tadd( output, 'row', rows );\n\t\tadd( output, 'column', columns );\n\t\tadd( output, 'cell', cells  );\n\n\t\tvar exisiting = el.children('span.select-info');\n\t\tif ( exisiting.length ) {\n\t\t\texisiting.remove();\n\t\t}\n\n\t\tif ( output.text() !== '' ) {\n\t\t\tel.append( output );\n\t\t}\n\t} );\n}\n\n/**\n * Initialisation of a new table. Attach event handlers and callbacks to allow\n * Select to operate correctly.\n *\n * This will occur _after_ the initial DataTables initialisation, although\n * before Ajax data is rendered, if there is ajax data\n *\n * @param  {DataTable.settings} ctx Settings object to operate on\n * @private\n */\nfunction init ( ctx ) {\n\tvar api = new DataTable.Api( ctx );\n\tctx._select_init = true;\n\n\t// Row callback so that classes can be added to rows and cells if the item\n\t// was selected before the element was created. This will happen with the\n\t// `deferRender` option enabled.\n\t// \n\t// This method of attaching to `aoRowCreatedCallback` is a hack until\n\t// DataTables has proper events for row manipulation If you are reviewing\n\t// this code to create your own plug-ins, please do not do this!\n\tctx.aoRowCreatedCallback.push( {\n\t\tfn: function ( row, data, index ) {\n\t\t\tvar i, ien;\n\t\t\tvar d = ctx.aoData[ index ];\n\n\t\t\t// Row\n\t\t\tif ( d._select_selected ) {\n\t\t\t\t$( row ).addClass( ctx._select.className );\n\t\t\t}\n\n\t\t\t// Cells and columns - if separated out, we would need to do two\n\t\t\t// loops, so it makes sense to combine them into a single one\n\t\t\tfor ( i=0, ien=ctx.aoColumns.length ; i<ien ; i++ ) {\n\t\t\t\tif ( ctx.aoColumns[i]._select_selected || (d._selected_cells && d._selected_cells[i]) ) {\n\t\t\t\t\t$(d.anCells[i]).addClass( ctx._select.className );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tsName: 'select-deferRender'\n\t} );\n\n\t// On Ajax reload we want to reselect all rows which are currently selected,\n\t// if there is an rowId (i.e. a unique value to identify each row with)\n\tapi.on( 'preXhr.dt.dtSelect', function (e, settings) {\n\t\tif (settings !== api.settings()[0]) {\n\t\t\t// Not triggered by our DataTable!\n\t\t\treturn;\n\t\t}\n\n\t\t// note that column selection doesn't need to be cached and then\n\t\t// reselected, as they are already selected\n\t\tvar rows = api.rows( { selected: true } ).ids( true ).filter( function ( d ) {\n\t\t\treturn d !== undefined;\n\t\t} );\n\n\t\tvar cells = api.cells( { selected: true } ).eq(0).map( function ( cellIdx ) {\n\t\t\tvar id = api.row( cellIdx.row ).id( true );\n\t\t\treturn id ?\n\t\t\t\t{ row: id, column: cellIdx.column } :\n\t\t\t\tundefined;\n\t\t} ).filter( function ( d ) {\n\t\t\treturn d !== undefined;\n\t\t} );\n\n\t\t// On the next draw, reselect the currently selected items\n\t\tapi.one( 'draw.dt.dtSelect', function () {\n\t\t\tapi.rows( rows ).select();\n\n\t\t\t// `cells` is not a cell index selector, so it needs a loop\n\t\t\tif ( cells.any() ) {\n\t\t\t\tcells.each( function ( id ) {\n\t\t\t\t\tapi.cells( id.row, id.column ).select();\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t} );\n\n\t// Update the table information element with selected item summary\n\tapi.on( 'draw.dtSelect.dt select.dtSelect.dt deselect.dtSelect.dt info.dt', function () {\n\t\tinfo( api );\n\t\tapi.state.save();\n\t} );\n\n\t// Clean up and release\n\tapi.on( 'destroy.dtSelect', function () {\n\t\t// Remove class directly rather than calling deselect - which would trigger events\n\t\t$(api.rows({selected: true}).nodes()).removeClass(api.settings()[0]._select.className);\n\n\t\tdisableMouseSelection( api );\n\t\tapi.off( '.dtSelect' );\n\t\t$('body').off('.dtSelect' + _safeId(api.table().node()));\n\t} );\n}\n\n/**\n * Add one or more items (rows or columns) to the selection when shift clicking\n * in OS selection style\n *\n * @param  {DataTable.Api} dt   DataTable\n * @param  {string}        type Row or column range selector\n * @param  {object}        idx  Item index to select to\n * @param  {object}        last Item index to select from\n * @private\n */\nfunction rowColumnRange( dt, type, idx, last )\n{\n\t// Add a range of rows from the last selected row to this one\n\tvar indexes = dt[type+'s']( { search: 'applied' } ).indexes();\n\tvar idx1 = $.inArray( last, indexes );\n\tvar idx2 = $.inArray( idx, indexes );\n\n\tif ( ! dt[type+'s']( { selected: true } ).any() && idx1 === -1 ) {\n\t\t// select from top to here - slightly odd, but both Windows and Mac OS\n\t\t// do this\n\t\tindexes.splice( $.inArray( idx, indexes )+1, indexes.length );\n\t}\n\telse {\n\t\t// reverse so we can shift click 'up' as well as down\n\t\tif ( idx1 > idx2 ) {\n\t\t\tvar tmp = idx2;\n\t\t\tidx2 = idx1;\n\t\t\tidx1 = tmp;\n\t\t}\n\n\t\tindexes.splice( idx2+1, indexes.length );\n\t\tindexes.splice( 0, idx1 );\n\t}\n\n\tif ( ! dt[type]( idx, { selected: true } ).any() ) {\n\t\t// Select range\n\t\tdt[type+'s']( indexes ).select();\n\t}\n\telse {\n\t\t// Deselect range - need to keep the clicked on row selected\n\t\tindexes.splice( $.inArray( idx, indexes ), 1 );\n\t\tdt[type+'s']( indexes ).deselect();\n\t}\n}\n\n/**\n * Clear all selected items\n *\n * @param  {DataTable.settings} ctx Settings object of the host DataTable\n * @param  {boolean} [force=false] Force the de-selection to happen, regardless\n *     of selection style\n * @private\n */\nfunction clear( ctx, force )\n{\n\tif ( force || ctx._select.style === 'single' ) {\n\t\tvar api = new DataTable.Api( ctx );\n\t\t\n\t\tapi.rows( { selected: true } ).deselect();\n\t\tapi.columns( { selected: true } ).deselect();\n\t\tapi.cells( { selected: true } ).deselect();\n\t}\n}\n\n/**\n * Select items based on the current configuration for style and items.\n *\n * @param  {object}             e    Mouse event object\n * @param  {DataTables.Api}     dt   DataTable\n * @param  {DataTable.settings} ctx  Settings object of the host DataTable\n * @param  {string}             type Items to select\n * @param  {int|object}         idx  Index of the item to select\n * @private\n */\nfunction typeSelect ( e, dt, ctx, type, idx )\n{\n\tvar style = dt.select.style();\n\tvar toggleable = dt.select.toggleable();\n\tvar isSelected = dt[type]( idx, { selected: true } ).any();\n\t\n\tif ( isSelected && ! toggleable ) {\n\t\treturn;\n\t}\n\n\tif ( style === 'os' ) {\n\t\tif ( e.ctrlKey || e.metaKey ) {\n\t\t\t// Add or remove from the selection\n\t\t\tdt[type]( idx ).select( ! isSelected );\n\t\t}\n\t\telse if ( e.shiftKey ) {\n\t\t\tif ( type === 'cell' ) {\n\t\t\t\tcellRange( dt, idx, ctx._select_lastCell || null );\n\t\t\t}\n\t\t\telse {\n\t\t\t\trowColumnRange( dt, type, idx, ctx._select_lastCell ?\n\t\t\t\t\tctx._select_lastCell[type] :\n\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// No cmd or shift click - deselect if selected, or select\n\t\t\t// this row only\n\t\t\tvar selected = dt[type+'s']( { selected: true } );\n\n\t\t\tif ( isSelected && selected.flatten().length === 1 ) {\n\t\t\t\tdt[type]( idx ).deselect();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tselected.deselect();\n\t\t\t\tdt[type]( idx ).select();\n\t\t\t}\n\t\t}\n\t} else if ( style == 'multi+shift' ) {\n\t\tif ( e.shiftKey ) {\n\t\t\tif ( type === 'cell' ) {\n\t\t\t\tcellRange( dt, idx, ctx._select_lastCell || null );\n\t\t\t}\n\t\t\telse {\n\t\t\t\trowColumnRange( dt, type, idx, ctx._select_lastCell ?\n\t\t\t\t\tctx._select_lastCell[type] :\n\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdt[ type ]( idx ).select( ! isSelected );\n\t\t}\n\t}\n\telse {\n\t\tdt[ type ]( idx ).select( ! isSelected );\n\t}\n}\n\nfunction _safeId( node ) {\n\treturn node.id.replace(/[^a-zA-Z0-9\\-\\_]/g, '-');\n}\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * DataTables selectors\n */\n\n// row and column are basically identical just assigned to different properties\n// and checking a different array, so we can dynamically create the functions to\n// reduce the code size\n$.each( [\n\t{ type: 'row', prop: 'aoData' },\n\t{ type: 'column', prop: 'aoColumns' }\n], function ( i, o ) {\n\tDataTable.ext.selector[ o.type ].push( function ( settings, opts, indexes ) {\n\t\tvar selected = opts.selected;\n\t\tvar data;\n\t\tvar out = [];\n\n\t\tif ( selected !== true && selected !== false ) {\n\t\t\treturn indexes;\n\t\t}\n\n\t\tfor ( var i=0, ien=indexes.length ; i<ien ; i++ ) {\n\t\t\tdata = settings[ o.prop ][ indexes[i] ];\n\n\t\t\tif ( (selected === true && data._select_selected === true) ||\n\t\t\t     (selected === false && ! data._select_selected )\n\t\t\t) {\n\t\t\t\tout.push( indexes[i] );\n\t\t\t}\n\t\t}\n\n\t\treturn out;\n\t} );\n} );\n\nDataTable.ext.selector.cell.push( function ( settings, opts, cells ) {\n\tvar selected = opts.selected;\n\tvar rowData;\n\tvar out = [];\n\n\tif ( selected === undefined ) {\n\t\treturn cells;\n\t}\n\n\tfor ( var i=0, ien=cells.length ; i<ien ; i++ ) {\n\t\trowData = settings.aoData[ cells[i].row ];\n\n\t\tif ( (selected === true && rowData._selected_cells && rowData._selected_cells[ cells[i].column ] === true) ||\n\t\t     (selected === false && ( ! rowData._selected_cells || ! rowData._selected_cells[ cells[i].column ] ) )\n\t\t) {\n\t\t\tout.push( cells[i] );\n\t\t}\n\t}\n\n\treturn out;\n} );\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * DataTables API\n *\n * For complete documentation, please refer to the docs/api directory or the\n * DataTables site\n */\n\n// Local variables to improve compression\nvar apiRegister = DataTable.Api.register;\nvar apiRegisterPlural = DataTable.Api.registerPlural;\n\napiRegister( 'select()', function () {\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tDataTable.select.init( new DataTable.Api( ctx ) );\n\t} );\n} );\n\napiRegister( 'select.blurable()', function ( flag ) {\n\tif ( flag === undefined ) {\n\t\treturn this.context[0]._select.blurable;\n\t}\n\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tctx._select.blurable = flag;\n\t} );\n} );\n\napiRegister( 'select.toggleable()', function ( flag ) {\n\tif ( flag === undefined ) {\n\t\treturn this.context[0]._select.toggleable;\n\t}\n\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tctx._select.toggleable = flag;\n\t} );\n} );\n\napiRegister( 'select.info()', function ( flag ) {\n\tif ( flag === undefined ) {\n\t\treturn this.context[0]._select.info;\n\t}\n\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tctx._select.info = flag;\n\t} );\n} );\n\napiRegister( 'select.items()', function ( items ) {\n\tif ( items === undefined ) {\n\t\treturn this.context[0]._select.items;\n\t}\n\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tctx._select.items = items;\n\n\t\teventTrigger( new DataTable.Api( ctx ), 'selectItems', [ items ] );\n\t} );\n} );\n\n// Takes effect from the _next_ selection. None disables future selection, but\n// does not clear the current selection. Use the `deselect` methods for that\napiRegister( 'select.style()', function ( style ) {\n\tif ( style === undefined ) {\n\t\treturn this.context[0]._select.style;\n\t}\n\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tif ( ! ctx._select ) {\n\t\t\tDataTable.select.init( new DataTable.Api(ctx) );\n\t\t}\n\n\t\tif ( ! ctx._select_init ) {\n\t\t\tinit(ctx);\n\t\t}\n\n\t\tctx._select.style = style;\n\n\t\t// Add / remove mouse event handlers. They aren't required when only\n\t\t// API selection is available\n\t\tvar dt = new DataTable.Api( ctx );\n\t\tdisableMouseSelection( dt );\n\t\t\n\t\tif ( style !== 'api' ) {\n\t\t\tenableMouseSelection( dt );\n\t\t}\n\n\t\teventTrigger( new DataTable.Api( ctx ), 'selectStyle', [ style ] );\n\t} );\n} );\n\napiRegister( 'select.selector()', function ( selector ) {\n\tif ( selector === undefined ) {\n\t\treturn this.context[0]._select.selector;\n\t}\n\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tdisableMouseSelection( new DataTable.Api( ctx ) );\n\n\t\tctx._select.selector = selector;\n\n\t\tif ( ctx._select.style !== 'api' ) {\n\t\t\tenableMouseSelection( new DataTable.Api( ctx ) );\n\t\t}\n\t} );\n} );\n\n\n\napiRegisterPlural( 'rows().select()', 'row().select()', function ( select ) {\n\tvar api = this;\n\n\tif ( select === false ) {\n\t\treturn this.deselect();\n\t}\n\n\tthis.iterator( 'row', function ( ctx, idx ) {\n\t\tclear( ctx );\n\n\t\tctx.aoData[ idx ]._select_selected = true;\n\t\t$( ctx.aoData[ idx ].nTr ).addClass( ctx._select.className );\n\t} );\n\n\tthis.iterator( 'table', function ( ctx, i ) {\n\t\teventTrigger( api, 'select', [ 'row', api[i] ], true );\n\t} );\n\n\treturn this;\n} );\n\napiRegister( 'row().selected()', function () {\n\tvar ctx = this.context[0];\n\n\tif (\n\t\tctx &&\n\t\tthis.length &&\n\t\tctx.aoData[this[0]] &&\n\t\tctx.aoData[this[0]]._select_selected\n\t) {\n\t\treturn true;\n\t}\n\n\treturn false;\n} );\n\napiRegisterPlural( 'columns().select()', 'column().select()', function ( select ) {\n\tvar api = this;\n\n\tif ( select === false ) {\n\t\treturn this.deselect();\n\t}\n\n\tthis.iterator( 'column', function ( ctx, idx ) {\n\t\tclear( ctx );\n\n\t\tctx.aoColumns[ idx ]._select_selected = true;\n\n\t\tvar column = new DataTable.Api( ctx ).column( idx );\n\n\t\t$( column.header() ).addClass( ctx._select.className );\n\t\t$( column.footer() ).addClass( ctx._select.className );\n\n\t\tcolumn.nodes().to$().addClass( ctx._select.className );\n\t} );\n\n\tthis.iterator( 'table', function ( ctx, i ) {\n\t\teventTrigger( api, 'select', [ 'column', api[i] ], true );\n\t} );\n\n\treturn this;\n} );\n\napiRegister( 'column().selected()', function () {\n\tvar ctx = this.context[0];\n\n\tif (\n\t\tctx &&\n\t\tthis.length &&\n\t\tctx.aoColumns[this[0]] &&\n\t\tctx.aoColumns[this[0]]._select_selected\n\t) {\n\t\treturn true;\n\t}\n\n\treturn false;\n} );\n\napiRegisterPlural( 'cells().select()', 'cell().select()', function ( select ) {\n\tvar api = this;\n\n\tif ( select === false ) {\n\t\treturn this.deselect();\n\t}\n\n\tthis.iterator( 'cell', function ( ctx, rowIdx, colIdx ) {\n\t\tclear( ctx );\n\n\t\tvar data = ctx.aoData[ rowIdx ];\n\n\t\tif ( data._selected_cells === undefined ) {\n\t\t\tdata._selected_cells = [];\n\t\t}\n\n\t\tdata._selected_cells[ colIdx ] = true;\n\n\t\tif ( data.anCells ) {\n\t\t\t$( data.anCells[ colIdx ] ).addClass( ctx._select.className );\n\t\t}\n\t} );\n\n\tthis.iterator( 'table', function ( ctx, i ) {\n\t\teventTrigger( api, 'select', [ 'cell', api.cells(api[i]).indexes().toArray() ], true );\n\t} );\n\n\treturn this;\n} );\n\napiRegister( 'cell().selected()', function () {\n\tvar ctx = this.context[0];\n\n\tif (ctx && this.length) {\n\t\tvar row = ctx.aoData[this[0][0].row];\n\n\t\tif (row && row._selected_cells && row._selected_cells[this[0][0].column]) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n} );\n\n\napiRegisterPlural( 'rows().deselect()', 'row().deselect()', function () {\n\tvar api = this;\n\n\tthis.iterator( 'row', function ( ctx, idx ) {\n\t\tctx.aoData[ idx ]._select_selected = false;\n\t\tctx._select_lastCell = null;\n\t\t$( ctx.aoData[ idx ].nTr ).removeClass( ctx._select.className );\n\t} );\n\n\tthis.iterator( 'table', function ( ctx, i ) {\n\t\teventTrigger( api, 'deselect', [ 'row', api[i] ], true );\n\t} );\n\n\treturn this;\n} );\n\napiRegisterPlural( 'columns().deselect()', 'column().deselect()', function () {\n\tvar api = this;\n\n\tthis.iterator( 'column', function ( ctx, idx ) {\n\t\tctx.aoColumns[ idx ]._select_selected = false;\n\n\t\tvar api = new DataTable.Api( ctx );\n\t\tvar column = api.column( idx );\n\n\t\t$( column.header() ).removeClass( ctx._select.className );\n\t\t$( column.footer() ).removeClass( ctx._select.className );\n\n\t\t// Need to loop over each cell, rather than just using\n\t\t// `column().nodes()` as cells which are individually selected should\n\t\t// not have the `selected` class removed from them\n\t\tapi.cells( null, idx ).indexes().each( function (cellIdx) {\n\t\t\tvar data = ctx.aoData[ cellIdx.row ];\n\t\t\tvar cellSelected = data._selected_cells;\n\n\t\t\tif ( data.anCells && (! cellSelected || ! cellSelected[ cellIdx.column ]) ) {\n\t\t\t\t$( data.anCells[ cellIdx.column  ] ).removeClass( ctx._select.className );\n\t\t\t}\n\t\t} );\n\t} );\n\n\tthis.iterator( 'table', function ( ctx, i ) {\n\t\teventTrigger( api, 'deselect', [ 'column', api[i] ], true );\n\t} );\n\n\treturn this;\n} );\n\napiRegisterPlural( 'cells().deselect()', 'cell().deselect()', function () {\n\tvar api = this;\n\n\tthis.iterator( 'cell', function ( ctx, rowIdx, colIdx ) {\n\t\tvar data = ctx.aoData[ rowIdx ];\n\n\t\tif(data._selected_cells !== undefined) {\n\t\t\tdata._selected_cells[ colIdx ] = false;\n\t\t}\n\n\t\t// Remove class only if the cells exist, and the cell is not column\n\t\t// selected, in which case the class should remain (since it is selected\n\t\t// in the column)\n\t\tif ( data.anCells && ! ctx.aoColumns[ colIdx ]._select_selected ) {\n\t\t\t$( data.anCells[ colIdx ] ).removeClass( ctx._select.className );\n\t\t}\n\t} );\n\n\tthis.iterator( 'table', function ( ctx, i ) {\n\t\teventTrigger( api, 'deselect', [ 'cell', api[i] ], true );\n\t} );\n\n\treturn this;\n} );\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Buttons\n */\nfunction i18n( label, def ) {\n\treturn function (dt) {\n\t\treturn dt.i18n( 'buttons.'+label, def );\n\t};\n}\n\n// Common events with suitable namespaces\nfunction namespacedEvents ( config ) {\n\tvar unique = config._eventNamespace;\n\n\treturn 'draw.dt.DT'+unique+' select.dt.DT'+unique+' deselect.dt.DT'+unique;\n}\n\nfunction enabled ( dt, config ) {\n\tif ( $.inArray( 'rows', config.limitTo ) !== -1 && dt.rows( { selected: true } ).any() ) {\n\t\treturn true;\n\t}\n\n\tif ( $.inArray( 'columns', config.limitTo ) !== -1 && dt.columns( { selected: true } ).any() ) {\n\t\treturn true;\n\t}\n\n\tif ( $.inArray( 'cells', config.limitTo ) !== -1 && dt.cells( { selected: true } ).any() ) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvar _buttonNamespace = 0;\n\n$.extend( DataTable.ext.buttons, {\n\tselected: {\n\t\ttext: i18n( 'selected', 'Selected' ),\n\t\tclassName: 'buttons-selected',\n\t\tlimitTo: [ 'rows', 'columns', 'cells' ],\n\t\tinit: function ( dt, node, config ) {\n\t\t\tvar that = this;\n\t\t\tconfig._eventNamespace = '.select'+(_buttonNamespace++);\n\n\t\t\t// .DT namespace listeners are removed by DataTables automatically\n\t\t\t// on table destroy\n\t\t\tdt.on( namespacedEvents(config), function () {\n\t\t\t\tthat.enable( enabled(dt, config) );\n\t\t\t} );\n\n\t\t\tthis.disable();\n\t\t},\n\t\tdestroy: function ( dt, node, config ) {\n\t\t\tdt.off( config._eventNamespace );\n\t\t}\n\t},\n\tselectedSingle: {\n\t\ttext: i18n( 'selectedSingle', 'Selected single' ),\n\t\tclassName: 'buttons-selected-single',\n\t\tinit: function ( dt, node, config ) {\n\t\t\tvar that = this;\n\t\t\tconfig._eventNamespace = '.select'+(_buttonNamespace++);\n\n\t\t\tdt.on( namespacedEvents(config), function () {\n\t\t\t\tvar count = dt.rows( { selected: true } ).flatten().length +\n\t\t\t\t            dt.columns( { selected: true } ).flatten().length +\n\t\t\t\t            dt.cells( { selected: true } ).flatten().length;\n\n\t\t\t\tthat.enable( count === 1 );\n\t\t\t} );\n\n\t\t\tthis.disable();\n\t\t},\n\t\tdestroy: function ( dt, node, config ) {\n\t\t\tdt.off( config._eventNamespace );\n\t\t}\n\t},\n\tselectAll: {\n\t\ttext: i18n( 'selectAll', 'Select all' ),\n\t\tclassName: 'buttons-select-all',\n\t\taction: function () {\n\t\t\tvar items = this.select.items();\n\t\t\tthis[ items+'s' ]().select();\n\t\t}\n\t},\n\tselectNone: {\n\t\ttext: i18n( 'selectNone', 'Deselect all' ),\n\t\tclassName: 'buttons-select-none',\n\t\taction: function () {\n\t\t\tclear( this.settings()[0], true );\n\t\t},\n\t\tinit: function ( dt, node, config ) {\n\t\t\tvar that = this;\n\t\t\tconfig._eventNamespace = '.select'+(_buttonNamespace++);\n\n\t\t\tdt.on( namespacedEvents(config), function () {\n\t\t\t\tvar count = dt.rows( { selected: true } ).flatten().length +\n\t\t\t\t            dt.columns( { selected: true } ).flatten().length +\n\t\t\t\t            dt.cells( { selected: true } ).flatten().length;\n\n\t\t\t\tthat.enable( count > 0 );\n\t\t\t} );\n\n\t\t\tthis.disable();\n\t\t},\n\t\tdestroy: function ( dt, node, config ) {\n\t\t\tdt.off( config._eventNamespace );\n\t\t}\n\t},\n\tshowSelected: {\n\t\ttext: i18n( 'showSelected', 'Show only selected' ),\n\t\tclassName: 'buttons-show-selected',\n\t\taction: function (e, dt, node, conf) {\n\t\t\t// Works by having a filtering function which will reduce to the selected\n\t\t\t// items only. So we can re-reference the function it gets stored in the\n\t\t\t// `conf` object\n\t\t\tif (conf._filter) {\n\t\t\t\tvar idx = DataTable.ext.search.indexOf(conf._filter);\n\n\t\t\t\tif (idx !== -1) {\n\t\t\t\t\tDataTable.ext.search.splice(idx, 1);\n\t\t\t\t\tconf._filter = null;\n\t\t\t\t}\n\n\t\t\t\tthis.active(false);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar fn = function (s, data, idx) {\n\t\t\t\t\t// Need to be sure we are operating on our table!\n\t\t\t\t\tif (s !== dt.settings()[0]) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet row = s.aoData[idx];\n\n\t\t\t\t\treturn row._select_selected;\n\t\t\t\t}\n\n\t\t\t\tconf._filter = fn;\n\t\t\t\tDataTable.ext.search.push(fn);\n\n\t\t\t\tthis.active(true);\n\t\t\t}\n\n\t\t\tdt.draw();\n\t\t}\n\t}\n} );\n\n$.each( [ 'Row', 'Column', 'Cell' ], function ( i, item ) {\n\tvar lc = item.toLowerCase();\n\n\tDataTable.ext.buttons[ 'select'+item+'s' ] = {\n\t\ttext: i18n( 'select'+item+'s', 'Select '+lc+'s' ),\n\t\tclassName: 'buttons-select-'+lc+'s',\n\t\taction: function () {\n\t\t\tthis.select.items( lc );\n\t\t},\n\t\tinit: function ( dt ) {\n\t\t\tvar that = this;\n\n\t\t\tdt.on( 'selectItems.dt.DT', function ( e, ctx, items ) {\n\t\t\t\tthat.active( items === lc );\n\t\t\t} );\n\t\t}\n\t};\n} );\n\n\n$.fn.DataTable.select = DataTable.select;\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Initialisation\n */\n\n// DataTables creation - check if select has been defined in the options. Note\n// this required that the table be in the document! If it isn't then something\n// needs to trigger this method unfortunately. The next major release of\n// DataTables will rework the events and address this.\n$(document).on( 'preInit.dt.dtSelect', function (e, ctx) {\n\tif ( e.namespace !== 'dt' ) {\n\t\treturn;\n\t}\n\n\tDataTable.select.init( new DataTable.Api( ctx ) );\n} );\n\n\nexport default DataTable;\n"],"names":[],"sourceRoot":""}